[
  {
    "objectID": "4_Feature_Extraction_and_Matching.html#a.-pengenalan-feature-extraction-and-matching",
    "href": "4_Feature_Extraction_and_Matching.html#a.-pengenalan-feature-extraction-and-matching",
    "title": "Modul 4. Feature Extraction and Matching",
    "section": "A. Pengenalan Feature Extraction and Matching",
    "text": "A. Pengenalan Feature Extraction and Matching\nEkstraksi dan Pencocokan Fitur adalah tugas penting dalam visi komputer, seperti struktur dari gerak, pengambilan gambar, dan deteksi objek.\nFitur adalah bagian dari informasi yang relevan untuk menyelesaikan tugas komputasi yang terkait dengan aplikasi tertentu. Fitur mungkin struktur tertentu dalam gambar seperti titik, tepi atau objek. Fitur mungkin juga merupakan hasil dari operasi lingkungan umum atau deteksi fitur yang diterapkan pada gambar. Fitur dapat diklasifikasikan menjadi dua kategori utama:\n\nFitur yang ada di lokasi tertentu dari gambar, seperti puncak gunung, sudut bangunan, pintu masuk, atau petak salju yang berbentuk menarik. Jenis fitur yang dilokalkan ini sering disebut fitur titik kunci (atau bahkan sudut) dan sering digambarkan dengan tampilan tambalan piksel yang mengelilingi lokasi titik.\n\nFitur yang dapat dicocokkan berdasarkan orientasi dan kenampakan lokalnya (profil tepi) disebut tepi dan juga dapat menjadi indikator yang baik untuk batasan objek dan kejadian oklusi dalam urutan citra.\n\nKomponen utama Deteksi dan Pencocokan Fitur:\nDeteksi : Identifikasi Feature Point.\nDeskripsi: Penampilan lokal di sekitar setiap titik fitur dijelaskan dalam beberapa cara yang (idealnya) tidak berubah di bawah perubahan iluminasi, translasi, skala, dan rotasi dalam bidang. Kami biasanya berakhir dengan vektor deskriptor untuk setiap titik fitur.\nPencocokan: Deskriptor dibandingkan di seluruh gambar, untuk mengidentifikasi fitur serupa. Untuk dua gambar kita mungkin mendapatkan satu set pasangan ( Xi, Yi ) ↔︎ ( Xi’, Yi’ ), di mana ( Xi, Yi ) adalah fitur dalam satu gambar dan ( Xi’, Yi’ ) fitur pencocokannya di gambar lainnya gambar.\n\nFeature Descriptor\nDeskriptor fitur adalah algoritme yang mengambil gambar dan menampilkan deskriptor fitur/vektor fitur. Deskriptor fitur menyandikan informasi menarik ke dalam rangkaian angka dan bertindak sebagai semacam “sidik jari” numerik yang dapat digunakan untuk membedakan satu fitur dari fitur lainnya.\n\n\n\nGambar… Macam-macam Feature Descriptor\n\n\nIdealnya, informasi ini akan menjadi invarian di bawah transformasi citra, sehingga kita dapat menemukan kembali fitur tersebut bahkan jika citra diubah dalam beberapa cara. Setelah mendeteksi feature point, kami melanjutkan untuk menghitung deskriptor untuk masing-masingnya. Deskriptor dapat dikategorikan menjadi dua kelas:\n\nDeskriptor Lokal: Ini adalah representasi kompak dari lingkungan lokal suatu titik. Deskriptor lokal mencoba untuk menyerupai bentuk dan penampilan hanya di lingkungan lokal sekitar titik dan dengan demikian sangat cocok untuk merepresentasikannya dalam hal pencocokan.\n\nDeskriptor Global : Deskriptor global menjelaskan keseluruhan gambar. Mereka umumnya tidak terlalu kuat karena perubahan sebagian gambar dapat menyebabkannya gagal karena akan memengaruhi deskriptor yang dihasilkan.\nMacam - macam Algoritma Descriptor :\n\nSIFT(Scale Invariant Feature Transform)\n\nSURF(Speed Up Robust Feature)\n\nORB(Oriented FAST and Rotate BRIEF)\n\nBRISK(Binary Robust Invariant Scalable Keypoints)\n\nBRIEF(Binary Robust Independent Elementary Feature)\n\n\n\nFeature Matching\nPencocokan fitur atau umumnya pencocokan gambar, bagian dari banyak aplikasi visi komputer seperti pendaftaran gambar, kalibrasi kamera dan pengenalan objek, adalah tugas membangun korespondensi antara dua gambar dari pemandangan/objek yang sama. Pendekatan umum untuk pencocokan citra terdiri dari pendeteksian sekumpulan poin kepentingan yang masing-masing terkait dengan deskriptor citra dari data citra. Setelah fitur dan deskriptornya diekstraksi dari dua atau lebih gambar, langkah selanjutnya adalah membuat beberapa pencocokan fitur awal antara gambar-gambar ini.\n\n\n\nGambar… Pencocokan gambar\n\n\nSecara umum, kinerja metode pencocokan berdasarkan interest point atau feature point bergantung pada properti dari feature point yang mendasarinya dan pilihan deskriptor gambar terkait. Dengan demikian, detektor dan deskriptor yang sesuai untuk konten gambar harus digunakan dalam aplikasi. Misalnya, jika gambar mengandung sel bakteri, detektor blob harus digunakan daripada detektor sudut. Tapi, jika gambar tersebut adalah pemandangan kota dari udara, detektor sudut cocok untuk menemukan struktur buatan manusia. Selain itu, pemilihan detektor dan deskriptor yang mengatasi degradasi citra sangatlah penting.\nMacam - macam Algoritma Pencocokan:\n\nBrute-Force Matcher\n\nFLANN(Fast Library for Aproximate Nearest Neighbors) Matcher"
  },
  {
    "objectID": "4_Feature_Extraction_and_Matching.html#b.-hog-dan-sift",
    "href": "4_Feature_Extraction_and_Matching.html#b.-hog-dan-sift",
    "title": "Modul 4. Feature Extraction and Matching",
    "section": "B. HOG dan SIFT",
    "text": "B. HOG dan SIFT\n\nHistogram of Oriented Gradient (HOG)\nHistogram of Oriented Gradients (HOG) adalah deskriptor fitur citra yang dapat digunakan untuk deteksi objek [52]. Untuk mengekstrak fitur ini, frekuensi orientasi gradien dalam bagian-bagian lokal citra dihitung. Penampilan dan bentuk objek lokal dalam sebuah citra dapat dijelaskan melalui distribusi gradien intensitas atau arah tepi. Langkah-langkah berikut perlu diimplementasikan untuk mengekstrak fitur HOG:\n\nPerhitungan gradien: Langkah pertama adalah menghitung gradien horizontal dan vertikal yang terpusat (Gx dan Gy) tanpa melakukan smoothing pada citra. Untuk tujuan ini, dapat digunakan operator Sobel atau operator deteksi tepi lainnya untuk mendapatkan gradien. Untuk citra berwarna, saluran warna yang memberikan magnitudo gradien tertinggi untuk setiap piksel dapat dipilih. Kemudian, magnitudo gradien dan orientasi gradien dihitung sebagai berikut:\n\n\n\n\nOrientasi pengalamatan: Langkah kedua adalah pembuatan histogram sel. Untuk ini, orientasi gradien diquantisasi ke dalam bin. Setiap bin akan mendapatkan voting berdasarkan magnitudo gradien. Voting juga dapat diberi bobot dengan filter Gaussian untuk mengurangi bobot piksel-piksel di dekat tepi blok.\n\n\n\n\n\nHistogram of oriented gradients: (a) cell histogram and (b) orientation binning\n\n\n\n\nMari kita ambil contoh ekstraksi deskriptor HOG. Untuk ini, kita menggunakan citra berukuran 64 x 128. Pertama, citra dibagi menjadi blok 16 x 16 dengan tumpang tindih 50%. Jadi, totalnya akan ada 7 x 15 = 105 blok. Setiap blok harus terdiri dari 2 x 2 sel dengan ukuran 8x8 piksel. Sekarang, orientasi gradien diquantisasi menjadi 9 bin. Di sini, voting adalah magnitudo gradien. Sekarang, voting diinterpolasi secara bilinear antara pusat bin yang berdekatan. Misalnya, misalkan orientasi adalah 75°. Kemudian, jarak antara pusat bin bin 70 dan bin 90 adalah 5° dan 15°, masing-masing. Oleh karena itu, rasio kepemilikan adalah 15/20 atau 3/4 dan 5/20 atau 1/4. Hal ini ditunjukkan secara diagramatik pada Gambar 3.24(a) dan (b). Histogram dari gradien yang diarahkan ditunjukkan pada Gambar 3.25.\n\nPenggabungan blok deskriptor: Histogram sel kemudian digabungkan untuk membentuk vektor fitur seperti yang ditunjukkan pada Gambar 3.26. Pada contoh kita, histogram yang diperoleh dari blok yang tumpang tindih 2 x 2 sel digabungkan menjadi vektor fitur 1-D dengan dimensi 105 x 2 x 2 x 9 = 3780.\n\nNormalisasi blok: Setiap blok dapat dinormalisasi dengan faktor normalisasi yang berbeda, seperti L2-norm, Zq-norm, Li-squared root norm, dll. Normalisasi blok membuat deskriptor invariant terhadap variasi pencahayaan dan fotometri.\n\nDeskriptor final: Deskriptor HOG akhir dapat digunakan untuk pengenalan objek. Deskriptor ini merupakan fitur untuk algoritma pembelajaran mesin, seperti Support Vector Machine (SVM).\n\n\n\n\n\nHasil HOG\n\n\n\n\n\n\nScale Invariant Feature Transform (SIFT)\nTransformasi fitur skala invarian (SIFT) adalah algoritma deteksi fitur untuk mendeteksi dan menggambarkan fitur lokal pada gambar untuk pengenalan objek. Detektor sudut Harris invarian terhadap translasi dan rotasi, tetapi tidak terhadap skala. Namun, algoritma SIFT dapat mendeteksi dan menggambarkan fitur lokal pada gambar. Fitur-fitur ini invarian terhadap translasi, penskalaan, dan rotasi gambar, serta sebagian invarian terhadap perubahan pencahayaan [55]. Fitur-fitur gambar yang diekstraksi dari gambar latihan harus tetap terdeteksi bahkan dengan perubahan skala gambar, noise, dan pencahayaan. Konsep skala memainkan peran penting dalam analisis gambar. Dalam analisis gambar, kita perlu mengekstraksi fitur gambar yang sesuai dengan menganalisis struktur gambar yang berbeda. Struktur-struktur ini mungkin ada pada skala yang berbeda. Jadi, jumlah informasi yang disampaikan oleh struktur gambar tertentu tergantung pada skala. SIFT mempertimbangkan masalah ini, yaitu fitur-fitur yang invariant terhadap perubahan skala. Langkah-langkah utama dari algoritma SIFT adalah sebagai berikut:\n\nEstimasi ekstremum skala-ruang: Ini sesuai dengan ekstremum DoG dan memastikan ekstraksi wilayah invarian skala. Tentukan lokasi perkiraan dan skala titik fitur yang menonjol (juga disebut “keypoints”).\n\nLokalisasi dan penyaringan titik fitur: Perbaiki lokasi dan skala mereka, yaitu pilih titik fitur yang asli dan buang yang buruk.\n\nPemberian orientasi: Tentukan orientasi untuk setiap titik fitur, yaitu kurangi efek rotasi.\n\nMembuat deskriptor: Menggunakan histogram deskriptor orientasi untuk setiap titik kunci.\n\nDeskriptor ini dibuat dengan menghitung histogram orientasi untuk setiap titik kunci. Deskriptor ini menangkap informasi gradien lokal di sekitar titik kunci dan memberikan representasi yang khas dari wilayah lokal. Langkah-langkah dalam membuat deskriptor adalah sebagai berikut:\n\nBagi wilayah di sekitar titik kunci menjadi sub-wilayah atau bin yang lebih kecil.\nUntuk setiap sub-wilayah, hitung magnitudo dan orientasi gradien piksel.\nTetapkan setiap piksel ke salah satu bin berdasarkan orientasi gradiennya.\nUntuk setiap bin, akumulasikan magnitudo gradien dari piksel yang ditugaskan.\nBuat histogram orientasi dengan mempertimbangkan magnitudo gradien yang terakumulasi sebagai bobot untuk setiap bin.\nNormalisasi histogram untuk membuatnya invarian terhadap perubahan pencahayaan.\nDeskriptor akhir terbentuk dengan menggabungkan histogram orientasi yang telah dinormalisasi.\n\nSetelah deskriptor dihitung untuk semua titik kunci, mereka dapat digunakan untuk berbagai aplikasi seperti pengenalan objek, penyatuan gambar, dan pencarian gambar. Pemadanan titik kunci di gambar-gambar yang berbeda berdasarkan deskriptornya memungkinkan pencocokan fitur yang kuat melintasi perubahan skala, rotasi, dan pencahayaan.\nUntuk mengimplementasikan algoritma SIFT dalam Python, dapat menggunakan pustaka OpenCV. OpenCV menyediakan fungsi-fungsi untuk deteksi titik kunci, perhitungan deskriptor, dan pencocokan fitur. Dapat merujuk pada dokumentasi dan tutorial OpenCV untuk informasi detail tentang cara menggunakan algoritma SIFT dalam Python.C. Feature Matching.\n\n\n\n\n\nGambar 3.27 Implementasi Langkah algoritma SIFT\n\n\n\nGambar 3.27 menunjukkan semua langkah implementasi dari algoritma SIFT. Langkah-langkah ini sekarang akan dijelaskan secara detail di bawah ini.\n\nDeteksi fitur skala-invarian: Langkah pertama adalah mendeteksi titik-titik unik (kunci) yang dapat dipilih kembali secara berulang dengan perubahan lokasi/skala. Untuk tujuan ini, seperti yang ditunjukkan di Gambar 3.28, digunakan representasi skala dengan menghitung piramida Laplacian yang dinormalisasi skala menggunakan difference of Gaussian (DoG) multiskala. Secara khusus, DoG dari citra D(x, y, σ) diberikan oleh:\nD(x, y, σ) = L(x, y, kiσ) — L(x, y, kjσ)\nDi mana, L(x, y, kσ) adalah hasil konvolusi dari citra asli f(x, y) dengan blur Gaussian G(x, y, kσ) pada skala kσ, dengan kata lain,\nL(x, y, kiσ) = G(x, y, kσ) * I(x, y)\n\n\n\n\n\nGambar 3.28 Formasi Laplacian Pyramid\n\n\n\n\nDeteksi puncak dalam skala-ruang: Pada tahap ini, titik-titik ekstrem lokal dideteksi dengan mempertimbangkan baik ruang maupun skala. Tujuannya adalah untuk mengidentifikasi lokasi dan skala yang dapat diberikan secara berulang dalam pandangan yang berbeda dari adegan atau objek yang sama. Pada kasus diskrit, hal ini ditentukan dengan membandingkan dengan 26 tetangga terdekat seperti yang ditunjukkan di Gambar 3.29.\n\n\n\n\n\n3.29. Scale-space peak detection\n\n\n\nLokalisasi titik kunci dan penolakan outlier: Selanjutnya, skala yang memberikan ekstremum dalam perbedaan Gaussian ditetapkan sebagai skala untuk titik kunci. Namun, deteksi ekstremum dalam skala-ruang menghasilkan banyak calon titik kunci. Namun demikian, beberapa titik kunci tidak stabil. Oleh karena itu, langkah berikutnya dari algoritma ini adalah menolak beberapa titik kunci yang memiliki kontras rendah atau yang terlokalisasi buruk di sepanjang tepi. Titik kunci dengan kontras rendah sensitif terhadap noise.\nPenghilangan titik kunci kontras rendah: Titik kunci dengan kontras rendah dan terlokalisasi buruk dihilangkan dengan menggunakan interpolasi subpiksel/subskala menggunakan ekspansi Taylor, yang diberikan oleh:\n\nDi mana, D dan turunannya dihitung di titik kunci calon dan x = (x, y, ) adalah offset dari titik ini. Lokasi puncak x diperkirakan dengan mempertimbangkan turunan fungsi ini terhadap x dan mengatur nilainya menjadi nol. Jika offset x lebih besar dari ambang batas yang telah ditentukan dalam dimensi manapun, maka hal ini menunjukkan bahwa puncak berada lebih dekat dengan titik kunci calon lainnya. Dalam hal ini, titik kunci calon harus diubah dan interpolasi dilakukan di sekitar titik tersebut. Jika tidak, offset ditambahkan ke titik kunci calon tersebut. Hal ini dilakukan untuk mendapatkan perkiraan yang diinterpolasi untuk lokasi puncak.\nPenghilangan respons tepi: Titik-titik tepi sesuai dengan kontras tinggi dalam satu arah dan rendah dalam arah lainnya. Fungsi DoG memiliki respons kuat di sepanjang tepi gambar. Titik kunci yang memiliki lokasi yang sangat tidak terdefinisi tetapi memiliki respons tepi tinggi dihilangkan. Langkah ini meningkatkan stabilitas. Puncak yang tidak terdefinisi dengan baik dalam fungsi DoG menunjukkan kelengkungan tinggi di sepanjang tepi dan nilai rendah dalam arah tegak lurus. Kelengkungan utama dapat dihitung dengan mengevaluasi matriks Hessian. Perlu dicatat bahwa untuk puncak yang tidak terdefinisi dengan baik dalam fungsi DoG, kelengkungan utama di sepanjang tepi jauh lebih besar daripada kelengkungan utama sepanjangnya. Untuk menemukan kelengkungan utama, kita perlu mencari solusi untuk eigenvalue dari matriks Hessian orde kedua H sebagai berikut:\n\nDalam persamaan di atas, rasio R hanya bergantung pada rasio eigenvalue r = A1/A2, dan R minimum ketika eigenvalue sama satu sama lain. Jika perbedaan absolut antara dua eigenvalue lebih tinggi, maka perbedaan absolut antara dua kelengkungan utama D juga akan lebih tinggi. Ini sesuai dengan nilai tinggi dari R. Oleh karena itu, eliminasi titik kunci dilakukan jika:\n\nPenugasan orientasi: Pada langkah ini, setiap titik kunci diberikan satu atau lebih orientasi. Orientasi ditentukan berdasarkan arah gradien citra lokal. Deskriptor titik kunci dapat direpresentasikan relatif terhadap orientasi ini. Itulah sebabnya, mereka invariant terhadap rotasi citra. Untuk ini, magnitudo dan orientasi pada citra yang telah dihaluskan dengan Gaussian (pada skala yang sesuai dengan titik kunci) dihitung. Pertama, citra yang telah dihaluskan dengan Gaussian L(x,y,a) pada skala titik kunci a diambil agar semua perhitungan terkait dilakukan dalam cara yang invariant terhadap skala. Untuk sampel citra L(x,y) pada skala σ, magnitudo gradien m(x,y) dan orientasi θ(x,y) dihitung menggunakan perbedaan piksel sebagai berikut:\n\nPerhitungan magnitudo dan arah untuk gradien harus dilakukan untuk setiap piksel tetangga di sekitar titik kunci dalam citra L yang telah dihaluskan dengan Gaussian. Selanjutnya, histogram orientasi dibentuk dari orientasi gradien titik sampel dalam sebuah wilayah di sekitar titik kunci. Histogram orientasi memiliki 36 bin yang mencakup rentang 360 derajat orientasi. Setiap sampel yang ditambahkan ke histogram diberi bobot berdasarkan magnitudo gradiennya dan oleh jendela lingkaran berbobot Gaussian. Puncak-puncak dalam histogram ini sesuai dengan orientasi dominan dari patch citra. Pada skala dan lokasi yang sama, dapat ada beberapa titik kunci dengan orientasi yang berbeda. Jika terdapat penugasan beberapa orientasi, titik kunci tambahan harus dibuat. Titik kunci tambahan tersebut harus memiliki lokasi dan skala yang sama dengan titik kunci asli untuk setiap orientasi tambahan. Jadi, setiap titik kunci memiliki parameter (x, y, 2, θ).\nDeskriptor titik kunci: Pada langkah-langkah sebelumnya, lokasi titik kunci pada skala tertentu telah ditemukan. Setelah itu, orientasi ditetapkan untuk titik kunci tersebut. Penugasan orientasi menjamin invariansi terhadap lokasi citra, skala, dan rotasi. Langkah selanjutnya adalah menghitung vektor deskriptor untuk masing-masing titik kunci. Tujuannya adalah membuat deskriptor menjadi sangat khas. Selain itu, deskriptor juga seharusnya sebagian invariant terhadap pencahayaan, sudut pandang 3D, dll. Langkah ini harus dilakukan pada citra yang paling mendekati skala titik kunci. Sebelum menghitung deskriptor, penting untuk memutar wilayah dengan nilai orientasi negatif (minus θ) yang terkait dengan titik kunci.\nPertama, sejumlah histogram orientasi dibuat pada subwilayah (lingkungan) piksel 4x4, dan 8 bin dialokasikan untuk setiap subwilayah tersebut. Histogram ini berasal dari magnitudo dan nilai orientasi dari sampel dalam wilayah 16x16 di sekitar titik kunci. Jadi, setiap histogram berisi sampel dari subwilayah 4x4 dari wilayah lingkungan asli. Selanjutnya, magnitudo diberi bobot dengan fungsi Gaussian. Deskriptor kemudian menjadi vektor yang berisi semua nilai dari histogram-histogram ini. Karena terdapat 4x4 = 16 histogram, masing-masing dengan 8 bin, vektor tersebut akan memiliki 128 elemen. Jadi, dimensi deskriptor atau vektor fitur akan menjadi 128. Vektor ini kemudian dinormalisasi menjadi panjang satuan untuk mengurangi efek variasi pencahayaan. Gambar 3.30 menunjukkan gradien gambar dan deskriptor titik kunci yang sesuai.\n\n\n menjadi \n\nUntuk aplikasi seperti pencarian gambar berbasis konten, fitur SIFT dapat dihitung untuk sekumpulan gambar dalam basis data, dan deskriptor-fiturnya disimpan dalam basis data tersebut. Begitu juga untuk sebuah gambar query, fitur SIFT dapat dihitung. Untuk pencocokan, deskriptor terdekat dalam basis data yang sesuai dengan deskriptor gambar query dapat ditemukan dengan menggunakan metrik jarak yang sesuai, dan gambar query tersebut dapat diambil kembali dari basis data.\nProses pencarian dapat dilakukan dengan membandingkan deskriptor-fitur gambar query dengan deskriptor-fitur gambar dalam basis data menggunakan metrik jarak seperti jarak Euclidean atau jarak cosine. Metrik jarak digunakan untuk mengukur sejauh mana kedua deskriptor-fitur tersebut mirip satu sama lain. Jika terdapat kemiripan yang signifikan antara deskriptor-fitur gambar query dengan deskriptor-fitur gambar dalam basis data, gambar-gambar tersebut dapat dianggap sebagai pencocokan potensial.\nSetelah pencocokan dilakukan, gambar-gambar dalam basis data dapat diurutkan berdasarkan tingkat kemiripan dengan gambar query. Gambar-gambar yang memiliki deskriptor-fitur yang paling mirip dengan gambar query akan muncul sebagai hasil teratas dalam hasil pencarian. Dengan demikian, gambar-gambar dalam basis data yang memiliki fitur yang mirip dengan gambar query dapat ditemukan dan dipulihkan dengan menggunakan fitur-fitur SIFT. Penggunaan fitur-fitur SIFT dalam aplikasi pencarian gambar berbasis konten memungkinkan pencarian yang lebih akurat dan efisien dengan mengabaikan perubahan skala, rotasi, dan pencahayaan dalam gambar."
  },
  {
    "objectID": "4_Feature_Extraction_and_Matching.html#c.-bow-dan-bovw",
    "href": "4_Feature_Extraction_and_Matching.html#c.-bow-dan-bovw",
    "title": "Modul 4. Feature Extraction and Matching",
    "section": "C. BoW dan BoVW",
    "text": "C. BoW dan BoVW\nBag of Word (BOW) pada awalnya tidak digunakan untuk visi komputer namun digunakan dalam bidang Text-Processin. Terkadang dalam konteks visi komputer Bag of Word disebut juga Bag of Visual Word. Namun Kita tetap akan menggunakan istilah BOW karena ini adalah istilah yang digunakan pada OpenCV.\nBoW adalah teknik yang digunakan untuk memberikan bobot atau hitungan untuk setiap kata dalam rangkaian dokumen; kita kemudian merepresentasikan dokumen-dokumen ini dengan vektor-vektor dari jumlah ini. Mari kita lihat pada sebuah contoh, sebagai berikut:\nDokumen 1: Saya suka Python dan Saya suka Java Dokumen 2: Saya suka Python dan C# Dokumen 3: Saya tidak suka pemrograman\nDari ketiga dokumen diatas dapat dibuat kamus atau kosakata, dengan nilai nilai sebagai berikut:\n{  \n    Saya : 4   \n    suka : 4  \n    Python : 2  \n    dan : 2  \n    Java : 1  \n    C# : 1  \n    tidak : 1  \n    pemrograman : 1  \n} \nKita memiliki 8 entri atau fitur yang nantinya akan direpresentasikan untuk dokumen 1,2, dan 3. Setiap vektor berisi nilai yang mewakili jumlah semua kata dalam kamus secara berurutan, untuk dokumen tertentu. Representasi vektor dari tiga kalimat sebelumnya adalah sebagai berikut:\n\nVektor-vektor ini dapat di konseptualisasikan sebagai representasi histogram dari sebuah dokumen atau sebagai vektor deskriptor yang dapat digunakan untuk pengklasifikasian.\nKonsep BOVW(Bag of Visual Word) diadaptasi dari BOW(Bag of Word) serta Information Retrieval yang ada pada NLP(Natural language Processing). BOW(Bag of Wors) bekerja dengan memakai frekuensi tiap kata-kata supaya mengetahui keywoard dari dokumen dengan menghitung berapa jumlah setiap katta yang muncul di dokumen (Davida, 2018).\nYang membedakan BOVW dengan BOW yaitu pada BOW yang digunakan adalah kata-kata, sedangkan BOVW menggunakan fitur-fitur gambar atau bisa dikatakan pola unik pada gambar yang berperan sebagai “kata-kata” yang ada di BOW. Setelah menghitung frekuensi, maka dari perhitungan frekuensi tersebut setiap fitur-fitur gambar dibuat histogram. Fitur itu sendiri tersusun dari deskriptor dan keypoints (Davida, 2018).\nSesuai dengan namanya, keypoints merupakan titik-titik yang menunjukan bagian-bagian gambar yang “menonjol”. Sedangkan deskriptor adalah gambaran dari keypoint. Dengan begitu, walaupun gambar dikecilkan, diperluas, diputar, letak titik-titik keypoint-nya akan tetap sama. Histogram frekuensi yang terbentuk dapat digunakan untuk memprediksi kategori citra serta menemukan citra lainnya yang mirip atau serupa (Davida, 2018)."
  },
  {
    "objectID": "4_Feature_Extraction_and_Matching.html#latihan-praktik",
    "href": "4_Feature_Extraction_and_Matching.html#latihan-praktik",
    "title": "Modul 4. Feature Extraction and Matching",
    "section": "Latihan Praktik",
    "text": "Latihan Praktik"
  },
  {
    "objectID": "1_Pengenalan_Computer_Vision_dan_Python.html#a.-pengenalan-computer-vision",
    "href": "1_Pengenalan_Computer_Vision_dan_Python.html#a.-pengenalan-computer-vision",
    "title": "Modul 1. Pengenalan Computer Vision dan Python",
    "section": "A. Pengenalan Computer Vision",
    "text": "A. Pengenalan Computer Vision\nVisi komputer adalah bidang ilmu komputer yang bertujuan untuk memungkinkan komputer memproses dan mengidentifikasi gambar dan video dengan cara yang sama seperti penglihatan manusia. Visi komputer bertujuan untuk meniru sistem visual manusia. Tujuan utamanya adalah membangun sistem buatan yang dapat mengekstrak informasi dari gambar, yaitu membuat komputer memahami gambar dan video. Data gambar dapat berupa urutan video, gambar kedalaman, pandangan dari beberapa kamera, atau data multidimensional dari sensor gambar. Tujuan utama visi komputer adalah menggambarkan sebuah scene dunia nyata dalam satu atau lebih gambar, dan mengidentifikasi serta merekonstruksi propertinya, seperti karakteristik warna, informasi bentuk, karakteristik tekstur, pencahayaan scene, dan sebagainya.\n\n\n\n\n\nGambar 1: Sistem penglihatan manusia (a) vs. visi komputer (b)\n\n\n\nKita dapat melihat kesamaan antara sistem penglihatan manusia dan sistem visi komputer. Seperti yang diilustrasikan dalam Gambar 1, prinsip dasar dari kedua sistem ini hampir sama, yaitu konversi cahaya menjadi sinyal/informasi yang berguna untuk membangun model akurat dari dunia fisik. Demikian pula, jika dilihat secara keseluruhan, struktur visi manusia dan visi komputer agak mirip, yaitu keduanya memiliki sensor cahaya yang mengubah foton menjadi sinyal (gambar), langkah pemrosesan, dan akhirnya mekanisme untuk menginterpretasi sinyal (pengenalan objek).\nPerbedaan antara visi komputer, pemrosesan gambar, dan grafika komputer dapat disimpulkan sebagai berikut:\nDalam Visi Komputer (analisis gambar, interpretasi gambar, pemahaman scene), inputnya adalah gambar dan outputnya adalah interpretasi sebuah scene. Analisis gambar berkaitan dengan pengukuran kuantitatif dari sebuah gambar untuk memberikan deskripsi tentang gambar tersebut. Dalam Pemrosesan Gambar (pemulihan gambar, rekonstruksi, penyaringan, kompresi, visualisasi), inputnya adalah gambar dan outputnya juga berupa gambar. Terakhir, dalam Grafika Komputer, inputnya adalah sebuah scene dunia nyata dan outputnya adalah sebuah gambar. Visi komputer membuat model dari gambar (analisis), sedangkan grafika komputer menggunakan model sebagai input dan mengonversinya menjadi gambar (synthesis). Dalam perspektif Hukum Bayes, konsep ini dapat dijelaskan sebagai berikut:\n\nDalam persamaan ini, P(Dunia|Gambar) merupakan Visi Komputer, P(Dunia) mengacu pada pemodelan objek dalam dunia nyata, dan P(Gambar|Dunia) adalah Grafika Komputer. Perspektif ini mendorong pendekatan pembelajaran statistik. Oleh karena itu, visi komputer berkaitan dengan pengembangan mesin-mesin yang dapat melihat dan berinteraksi dengan dunia.\nKonsep ini diilustrasikan dalam Gambar 2.\n\n\n\n\n\nGambar 2: Visi Komputer vs Grafika Komputer\n\n\n\nVisi komputer saat ini digunakan dalam berbagai aplikasi dunia nyata, termasuk inspeksi mesin, pengenalan karakter optik (OCR), pembangunan model 3D (fotogrametri), analisis gambar medis, pengawasan video otomatis, biometrik, fusi dan penyambungan gambar, morphing, pemodelan 3D, dan lain-lain. Seperti yang ditunjukkan dalam Gambar 3, visi komputer terkait dengan banyak bidang penelitian penting.\n\n\n\n\n\nGambar 3: Computer vision dan disiplin terkait\n\n\n\nSelain itu, visi komputer juga menghadapi tantangan etika dan privasi. Penggunaan visi komputer dalam pengawasan dan pengenalan wajah telah menimbulkan pertanyaan tentang privasi dan hak individu. Bagaimana data visual dikumpulkan, digunakan, dan disimpan perlu diatur dengan hati-hati untuk melindungi privasi individu dan mencegah penyalahgunaan teknologi.\nNamun, dengan penelitian dan pengembangan yang berkelanjutan, visi komputer, sebagai subbidang ilmu komputer dengan tujuan membangun mesin agar bisa memproses dan menginterpretasikan gambar dan video seperti yang dilakukan sistem visual manusia, terus berkembang dan memperbaiki keterbatasannya, menawarkan prospek yang menjanjikan untuk masa depan."
  },
  {
    "objectID": "1_Pengenalan_Computer_Vision_dan_Python.html#b.-pengenalan-python",
    "href": "1_Pengenalan_Computer_Vision_dan_Python.html#b.-pengenalan-python",
    "title": "Modul 1. Pengenalan Computer Vision dan Python",
    "section": "B. Pengenalan Python",
    "text": "B. Pengenalan Python\nPython adalah sebuah bahasa pemrograman yang telah matang dan menawarkan sifat open source, yang berarti kode sumbernya tersedia secara bebas dan dapat diubah atau dikembangkan lebih lanjut oleh siapa saja. Sebagai bahasa yang mudah dipelajari, Python telah berhasil mengumpulkan basis pengguna yang sangat luas. Komunitas ini, yang terdiri dari jutaan pengguna di seluruh dunia, siap membantu Anda mengembangkan keterampilan dan pemahaman Anda tentang Python, baik Anda seorang pemula atau programmer berpengalaman.\nBasis pengguna Python, yang beragam dan aktif, telah berkontribusi pada pengembangan berbagai alat dan perpustakaan pendukung. Perpustakaan ini adalah kumpulan rutinitas yang telah dikompilasi sebelumnya, dan dirancang untuk memfasilitasi berbagai upaya ilmiah dan teknis. Mulai dari data science, machine learning, pemrosesan bahasa, robotika, hingga visi komputer, Python telah memberikan solusi yang kuat dan fleksibel. Itulah sebabnya Python telah menjadi salah satu bahasa komputasi ilmiah yang paling penting, baik dalam lingkungan akademisi maupun industri.\nPopularitas Python tentu saja datang dengan tantangannya sendiri. Seperti hutan belantara, ekosistem Python telah berkembang menjadi sesuatu yang tampak rumit dan sulit ditembus. Beberapa ilmuwan dan profesional baru dalam dunia Python mungkin merasa frustrasi dan stres saat berhadapan dengan banyaknya pilihan yang tersedia. Mereka harus membuat keputusan penting seperti perpustakaan mana yang harus digunakan untuk menggambar grafik atau editor teks mana yang harus digunakan untuk menulis program mereka.\nFleksibilitas Python datang sebagai solusi. Python mampu menangani berbagai format data, menjalankan peralatan ilmiah, dan berintegrasi dengan bahasa tingkat rendah seperti C, C++, dan FORTRAN. Python dapat digunakan sebagai “bahasa perekat”, memungkinkan integrasi berbagai skrip atau sistem yang berbeda. Jadi, meskipun ada banyak pilihan, Python menawarkan kemampuan untuk memilih dan menyesuaikan sesuai dengan kebutuhan spesifik Anda, yang menjadikannya lebih mudah bagi pengguna baru untuk memulai dan berkembang."
  },
  {
    "objectID": "1_Pengenalan_Computer_Vision_dan_Python.html#c.-python-untuk-computer-vision",
    "href": "1_Pengenalan_Computer_Vision_dan_Python.html#c.-python-untuk-computer-vision",
    "title": "Modul 1. Pengenalan Computer Vision dan Python",
    "section": "C. Python untuk Computer Vision",
    "text": "C. Python untuk Computer Vision\nComputer Vision adalah sebuah cabang dari ilmu komputer yang memungkinkan mesin untuk memahami dan memanipulasi konten visual. Dengan adanya teknologi ini, kita bisa mendapatkan banyak keuntungan seperti dalam pengenalan wajah, deteksi objek, hingga analisis gambar dan video dalam bidang medis. Dalam bidang ini, Python telah menjadi bahasa pemrograman yang sangat berharga dan penting.\nPython adalah bahasa pemrograman yang telah matang dan terbuka (open-source), membuatnya menjadi pilihan yang sangat baik untuk computer vision. Python menyediakan sintaks yang mudah dibaca dan dipahami, sehingga memudahkan pengguna baru untuk memahami dan memanfaatkan berbagai perpustakaan pendukung yang tersedia untuk computer vision. Di antara perpustakaan tersebut, ada OpenCV, TensorFlow, dan PyTorch, yang semuanya penting untuk pengembangan dan implementasi solusi computer vision.\nOpenCV (Open Source Computer Vision Library) adalah perpustakaan yang sangat populer dalam bidang pengolahan gambar dan computer vision. Dikembangkan oleh Intel dan disebarkan dengan lisensi BSD, OpenCV memungkinkan pengembangan solusi computer vision dengan cepat dan efisien, baik untuk aplikasi real-time maupun offline.\nSementara itu, TensorFlow dan PyTorch adalah kerangka kerja pembelajaran mesin yang mendukung operasi yang diperlukan untuk pekerjaan computer vision. Keduanya mendukung teknik pembelajaran mesin canggih seperti jaringan saraf dan pembelajaran mendalam (deep learning) yang sering digunakan dalam aplikasi computer vision modern.\nPython juga memiliki kelebihan dalam penanganan data visual. Dengan Python, pengguna dapat dengan mudah membaca, menulis, dan memanipulasi gambar dan video dalam berbagai format. Python juga mendukung operasi pra-pemrosesan yang diperlukan untuk data visual, seperti perubahan ukuran gambar, normalisasi, dan augmentasi data.\nTerakhir, Python juga menawarkan kemudahan dalam visualisasi data dan hasil. Dengan menggunakan perpustakaan seperti Matplotlib dan Seaborn, pengguna dapat dengan mudah memvisualisasikan data dan hasil dalam berbagai format. Dengan kata lain, dengan Python, computer vision menjadi lebih mudah diakses dan dipahami, baik oleh profesional maupun pemula. Python telah membuktikan dirinya sebagai bahasa pemrograman yang kuat dan fleksibel yang dapat mendukung berbagai tugas dan proyek dalam bidang computer vision."
  },
  {
    "objectID": "1_Pengenalan_Computer_Vision_dan_Python.html#d.-latihan-praktik",
    "href": "1_Pengenalan_Computer_Vision_dan_Python.html#d.-latihan-praktik",
    "title": "Modul 1. Pengenalan Computer Vision dan Python",
    "section": "D. Latihan Praktik",
    "text": "D. Latihan Praktik\nPython merupakan bahasa pemrograman yang ideal untuk belajar dan menerapkan visi komputer. Berikut adalah beberapa latihan praktik yang dapat Anda lakukan untuk meningkatkan keterampilan visi komputer Anda menggunakan Python.\nLatihan 1: Membaca dan Menampilkan Gambar\nTujuan dari latihan ini adalah untuk memahami cara membaca dan menampilkan gambar menggunakan Python dan OpenCV, sebuah pustaka yang sering digunakan dalam visi komputer.\nimport cv2\n\n# Membaca gambar\ngambar = cv2.imread('namafile.jpg')\n\n# Menampilkan gambar\ncv2.imshow('Gambar', gambar)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\nBerikut adalah fungsi dari setiap baris kode:\n\nimport cv2: Ini adalah perintah untuk mengimpor library OpenCV (cv2) ke dalam program Python. OpenCV adalah library populer yang digunakan untuk memanipulasi gambar dan video.\ngambar = cv2.imread(‘namafile.jpg’): Baris ini membaca gambar dengan nama file ‘namafile.jpg’ menggunakan fungsi imread() dari OpenCV. Fungsi ini mengembalikan matriks NumPy yang mewakili gambar.\ncv2.imshow(‘Gambar’, gambar): Ini adalah perintah untuk menampilkan gambar ke jendela dengan judul ‘Gambar’. Fungsi imshow() dari OpenCV digunakan untuk menampilkan gambar dalam jendela.\ncv2.waitKey(0): Baris ini menunggu pengguna menekan tombol apa pun untuk melanjutkan eksekusi program. Nilai argumen 0 menunjukkan bahwa program akan tetap berjalan sampai tombol ditekan.\ncv2.destroyAllWindows(): Ini adalah perintah untuk menutup semua jendela yang dibuka oleh program. Fungsi destroyAllWindows() digunakan untuk membersihkan semua jendela tampilan.\n\nLatihan 2: Mengubah Gambar ke Grayscale\nBanyak operasi dalam visi komputer dijalankan pada gambar grayscale. Latihan ini bertujuan untuk mengubah gambar berwarna menjadi grayscale.\nimport cv2\n\n# Membaca gambar\ngambar = cv2.imread('namafile.jpg')\n\n# Mengubah gambar ke grayscale\ngray = cv2.cvtColor(gambar, cv2.COLOR_BGR2GRAY)\n\n# Menampilkan gambar grayscale\ncv2.imshow('Gambar Grayscale', gray)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\nBerikut adalah fungsi dari setiap baris kode:\n\ngray = cv2.cvtColor(gambar, cv2.COLOR_BGR2GRAY): Baris ini mengubah gambar dari warna (BGR) ke skala keabuan (grayscale) menggunakan fungsi cvtColor() dari OpenCV. Fungsi ini menerima dua argumen, yaitu gambar yang ingin diubah (variabel gambar) dan konversi warna yang ingin dilakukan (dalam hal ini, dari BGR ke grayscale). Hasil konversi disimpan dalam variabel gray.\n\nLatihan 3: Deteksi Tepi\nDeteksi tepi adalah teknik penting dalam visi komputer. Latihan ini bertujuan untuk menerapkan deteksi tepi pada gambar.\nimport cv2\nimport numpy as np\n\n# Membaca gambar\ngambar = cv2.imread('namafile.jpg')\n\n# Mengubah gambar ke grayscale\ngray = cv2.cvtColor(gambar, cv2.COLOR_BGR2GRAY)\n\n# Mengaplikasikan deteksi tepi\nedges = cv2.Canny(gray, 30, 100)\n\n# Menampilkan gambar dengan tepi yang terdeteksi\ncv2.imshow('Deteksi Tepi', edges)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\nBerikut adalah fungsi dari setiap baris kode:\n\nedges = cv2.Canny(gray, 30, 100): Baris ini menerapkan deteksi tepi pada gambar skala keabuan (grayscale) menggunakan metode Canny dengan parameter threshold lower dan upper sebesar 30 dan 100. Fungsi Canny() dari OpenCV menghasilkan gambar dengan tepi yang terdeteksi, yang disimpan dalam variabel edges.\n\nLatihan 4: Deteksi Wajah\nPustaka OpenCV menyediakan pretrained cascade classifiers yang dapat digunakan untuk deteksi wajah dan fitur wajah lainnya.\nimport cv2\n\n# Membaca gambar\ngambar = cv2.imread('namafile.jpg')\n\n# Mengubah gambar ke grayscale\ngray = cv2.cvtColor(gambar, cv2.COLOR_BGR2GRAY)\n\n# Membuat objek face cascade\nface_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + \"haarcascade_frontalface_default.xml\")\n\n# Mendeteksi wajah\nfaces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))\n\n# Menggambar kotak pada setiap wajah yang terdeteksi\nfor (x, y, w, h) in faces:\n    cv2.rectangle(gambar, (x, y), (x+w, y+h), (0, 255, 0), 2)\n\n# Menampilkan gambar dengan wajah yang terdeteksi\ncv2.imshow('Deteksi Wajah', gambar)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\nBerikut adalah fungsi dari setiap baris kode:\n\nface_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + “haarcascade_frontalface_default.xml”): Baris ini membuat objek cascade classifier untuk mendeteksi wajah. Cascade classifier adalah algoritma yang digunakan untuk mendeteksi objek dalam gambar berdasarkan fitur-fitur yang telah ditraining sebelumnya. Dalam hal ini, digunakan cascade classifier untuk mendeteksi wajah dengan menggunakan file XML yang disebut “haarcascade_frontalface_default.xml”. File XML ini berisi informasi tentang fitur-fitur yang relevan untuk mendeteksi wajah.\nfaces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30)): Baris ini mendeteksi wajah dalam gambar menggunakan metode detectMultiScale() dari cascade classifier. Metode ini menerima gambar skala keabuan (gray) sebagai input dan mengembalikan array yang berisi koordinat wajah yang terdeteksi. Parameter-parameter yang digunakan adalah scaleFactor (faktor skala untuk deteksi multi-skala), minNeighbors (jumlah minimum tetangga yang harus ada agar wajah dianggap valid), dan minSize (ukuran minimum wajah yang diterima).\nfor (x, y, w, h) in faces: cv2.rectangle(gambar, (x, y), (x+w, y+h), (0, 255, 0), 2): Baris ini menggunakan loop untuk menggambar kotak pada setiap wajah yang terdeteksi. Koordinat dan ukuran wajah yang terdeteksi (x, y, w, h) diperoleh dari array wajah yang ditemukan sebelumnya. Kotak tersebut digambar menggunakan fungsi rectangle() dari OpenCV pada gambar asli (variabel gambar).\n\nHarap diingat bahwa setiap latihan ini hanyalah awal. Visi komputer adalah bidang yang sangat luas dengan banyak teknik dan algoritma yang berbeda. Untuk benar-benar mahir, Anda perlu memahami teori di balik teknik ini dan bagaimana menerapkannya dalam situasi nyata."
  },
  {
    "objectID": "1_Pengenalan_Computer_Vision_dan_Python.html#e.-sesi-tanya-jawab-dan-diskusi",
    "href": "1_Pengenalan_Computer_Vision_dan_Python.html#e.-sesi-tanya-jawab-dan-diskusi",
    "title": "Modul 1. Pengenalan Computer Vision dan Python",
    "section": "E. Sesi Tanya Jawab dan Diskusi",
    "text": "E. Sesi Tanya Jawab dan Diskusi\nQ: Apa itu computer vision dan mengapa itu penting?\nA: Computer vision adalah bidang teknologi yang memungkinkan komputer dan mesin untuk ‘melihat’ dan memahami konten visual, seperti gambar dan video. Computer vision penting karena memungkinkan automasi dan analisis tingkat lanjut dalam berbagai bidang, seperti keamanan, kesehatan, manufaktur, dan banyak lagi.\nQ: Mengapa Python sering digunakan dalam computer vision?\nA: Python sering digunakan dalam computer vision karena mudah dipelajari, memiliki sintaks yang jelas dan bersih, dan didukung oleh banyak library dan framework yang kuat seperti OpenCV, TensorFlow, dan PyTorch. Python juga open-source, yang berarti kode sumbernya tersedia secara bebas dan dapat dimodifikasi atau diperluas oleh komunitas.\nQ: Bagaimana saya bisa belajar lebih banyak tentang computer vision dan Python?\nA: Anda bisa memulai dengan belajar dasar-dasar Python dan lalu belajar tentang perpustakaan seperti OpenCV, TensorFlow, dan PyTorch. Anda juga bisa mengikuti and 1 attachments\nQ: Saya baru belajar Python, apakah saya bisa belajar Computer Vision?\nA: Ya, Anda bisa belajar Computer Vision meski baru belajar Python. Sebenarnya, Python adalah bahasa pemrograman yang baik untuk dipelajari jika Anda tertarik dengan Computer Vision karena memiliki banyak library dan framework, seperti OpenCV, TensorFlow, dan PyTorch, yang dirancang khusus untuk visi komputer dan pembelajaran mesin.\nQ: Apa yang dimaksud dengan Object Detection dalam Computer Vision?\nA: Object Detection adalah teknologi dalam visi komputer yang mengidentifikasi atau mendeteksi objek dari berbagai kelas (seperti manusia, kendaraan, atau hewan) dalam gambar atau video. Teknologi ini biasanya digunakan dalam aplikasi seperti pengawasan video, sistem navigasi untuk kendaraan otonom, dan banyak lagi.\nQ: Apakah memungkinkan untuk melakukan Computer Vision tanpa Machine Learning?\nA: Ya, memang memungkinkan untuk melakukan tugas-tugas visi komputer tertentu tanpa menggunakan Machine Learning. Misalnya, teknik seperti pengolahan gambar, deteksi tepi, dan thresholding bisa digunakan untuk ekstraksi fitur dan pemrosesan gambar dasar. Namun, untuk tugas yang lebih kompleks seperti deteksi objek, pengenalan wajah, dan analisis video, biasanya diperlukan teknik Machine Learning atau Deep Learning."
  },
  {
    "objectID": "2_Python.html#a.-dasar-dasar-python",
    "href": "2_Python.html#a.-dasar-dasar-python",
    "title": "Modul 2. Python",
    "section": "A. Dasar-dasar Python",
    "text": "A. Dasar-dasar Python\n\nApa itu Python?\nPython adalah bahasa pemrograman tingkat tinggi yang populer. Bahasa ini dapat menangani berbagai tugas pemrograman seperti komputasi numerik, pengembangan web, pemrograman basis data, pemrograman jaringan, pemrosesan paralel, dan lainnya.\nPython populer karena berbagai alasan, termasuk:\n\nBahasa ini gratis.\n\nTersedia di semua sistem operasi populer seperti Windows, Mac, atau Linux.\n\nPython adalah bahasa yang diinterpretasikan. Oleh karena itu, pemrogram dapat menguji bagian kode di baris perintah sebelum menggabungkannya ke dalam program mereka. Tidak ada kebutuhan untuk kompilasi atau penghubungan. Python memungkinkan pemrograman yang lebih cepat.\n\nPython lebih sederhana secara sintaksis dibandingkan dengan C/C++/Fortran. Oleh karena itu, Python sangat mudah dibaca dan lebih mudah untuk debug.\n\nPython datang dengan berbagai modul yang standar atau dapat diinstal dalam instalasi Python yang ada. Modul-modul ini dapat melakukan berbagai tugas seperti membaca dan menulis berbagai file, komputasi ilmiah, visualisasi data, dan lainnya.\n\nProgram yang ditulis dalam Python dapat dijalankan di berbagai sistem operasi atau platform dengan sedikit atau tanpa perubahan.\n\nPython adalah bahasa yang dinamis dalam pengetikannya. Oleh karena itu, tipe data dari variabel tidak harus dinyatakan sebelum penggunaannya, membuatnya lebih mudah untuk orang dengan pengalaman coding yang kurang.\n\nPython memiliki komunitas pengembang dan pengguna yang berdedikasi dan selalu diperbarui.\nMeskipun Python memiliki banyak keunggulan yang membuatnya menjadi salah satu bahasa yang diinterpretasikan paling populer, Python memiliki beberapa kelemahan yang dibahas di bawah ini:\n\nKarena fokus Python adalah pada kemampuan untuk pemrograman yang lebih cepat, kecepatan eksekusi menderita. Program Python mungkin 10 kali atau lebih lambat (misalnya) dibandingkan dengan program C yang setara, tetapi program Python akan berisi lebih sedikit baris kode dan dapat diprogram untuk menangani berbagai jenis data dengan mudah. Kelemahan ini dalam kode Python dapat diatasi dengan mengubah bagian kode yang intensif secara komputasi ke C/C++ atau dengan penggunaan struktur data dan modul yang tepat.\n\nIndentasi kode tidak opsional. Ini membuat kode mudah dibaca. Namun, kode dengan loop dan konstruk lainnya akan diindentasi ke kanan, membuatnya sulit untuk membaca kode.\n\n\n\nLingkungan Python\nTerdapat beberapa lingkungan Python yang dapat dipilih. Beberapa sistem operasi seperti Mac, Linux, Unix, dan lainnya memiliki interpreter bawaan. Interpreter tersebut mungkin mengandung semua modul tetapi tidak siap pakai untuk komputasi ilmiah. Distribusi khusus telah dibuat dan dijual kepada komunitas ilmiah, dibangun sebelumnya dengan berbagai modul ilmiah Python. Saat menggunakan distribusi ini, pengguna tidak perlu menginstal modul ilmiah secara individual. Jika modul tertentu yang diminati tidak tersedia dalam distribusi, modul tersebut dapat diinstal. Salah satu distribusi paling populer adalah Anaconda. Instruksi untuk menginstal distribusi Anaconda dapat ditemukan di www.anaconda.com\n\nInterpreter Python\nInterpreter Python yang terintegrasi dalam sebagian besar sistem operasi dapat dimulai dengan hanya mengetik python di jendela terminal. Ketika interpreter dimulai, prompt perintah (&gt;&gt;&gt;) muncul. Perintah Python dapat dimasukkan di prompt untuk diproses. Misalnya, di Windows, ketika interpreter Python bawaan dimulai, output yang mirip dengan yang ditunjukkan di bawah ini muncul:\n\nPerhatikan bahwa dalam contoh di atas, interpreter Python adalah versi 3.10.5. Kemungkinan Anda mungkin memiliki versi yang berbeda.\n\n\nDistribusi Python\nDistribusi Python Anaconda menyediakan hampir 100 modul Python ilmiah paling populer seperti perhitungan ilmiah, aljabar linear, komputasi simbolik, pemrosesan gambar, pemrosesan sinyal, visualisasi, integrasi program C/C++ ke Python, dll. Ini didistribusikan dan dikelola oleh Continuum Analytics. Ini tersedia secara gratis untuk akademisi dan tersedia dengan harga untuk semua orang lainnya. Selain berbagai modul yang dibangun ke dalam Anaconda, pemrogram dapat menginstal modul lain menggunakan manajer paket conda [Ana20b], tanpa mempengaruhi distribusi utama. Untuk mengakses Python dari baris perintah, mulailah ‘Anaconda Prompt’ yang dapat dieksekusi\n\ndan kemudian ketik python.\n\n\n\n\nMenjalankan Program Python\nMenggunakan interpreter Python apa pun (bawaan atau dari distribusi), Anda dapat menjalankan program Anda menggunakan perintah di sistem operasi (OS) prompt perintah. Jika file firstprog.py adalah file Python yang perlu dieksekusi, kemudian ketik perintah berikut ini di OS prompt perintah.\npython latihanPython.py\nSimbol &gt;&gt; adalah prompt terminal dan &gt;&gt;&gt; mewakili prompt Python. Pendekatan terbaik untuk menjalankan program Python di bawah sistem operasi apa pun adalah dengan menggunakan Lingkungan Pengembangan Terpadu seperti IDLE atau Spyder karena memberikan kemampuan untuk mengedit file dan juga menjalankannya di bawah antarmuka yang sama.\nBuka CMD lalu pindah Directiory menggunakan command cd\n\nJalankan file dengan ekstensi .py\n\n\n\nPernyataan Dasar Python dan Jenis Data\nIndentasi\nDalam Python, blok kode ditunjukkan dengan indentasi. Misalnya dalam kode di bawah ini, kita pertama-tama mencetak pesan, ‘Kami sedang menghitung kuadrat dari angka antara 0 dan 9’. Kemudian kita melakukan loop melalui nilai-nilai dalam rentang 0 hingga 9 dan menyimpannya dalam variabel ‘i’ dan juga mencetak kuadrat dari ‘i’. Akhirnya kita mencetak pesan, ’Kami menyelesaikan tugas di akhir.\nDalam bahasa lain, blok kode di bawah for-loop akan diidentifikasi dengan pasangan kurung kurawal {}. Namun, dalam Python kita tidak menggunakan kurung kurawal. Blok kode diidentifikasi dengan menggeser baris print(i*i) empat spasi ke kanan. Anda juga bisa memilih untuk menggunakan tab sebagai gantinya.\nprint('Menghitung kuadrat dari angka antara 0 dan 9') \nfor i in range(10):\n    print(i*i)\nprint('Menyelesaikan tugas ...')\nAda kelemahan signifikan dalam indentasi, terutama bagi pemrogram Python baru. Sebuah kode yang berisi beberapa for-loop dan if-statements akan diindentasi lebih jauh ke kanan membuat kode tidak dapat dibaca. Masalah ini dapat diredakan dengan mengurangi jumlah for-loop dan if-statements. Ini tidak hanya membuat kode dapat dibaca tetapi juga mengurangi waktu komputasi. Ini dapat dicapai dengan pemrograman menggunakan struktur data seperti daftar, kamus, dan set secara tepat.\nKomentar\nKomentar adalah bagian penting dari setiap bahasa pemrograman. Dalam Python, komentar baris tunggal ditandai dengan hash # di awal baris. Beberapa baris dapat dikomentari dengan menggunakan string tanda kutip tiga (tanda kutip tunggal tiga kali atau tanda kutip ganda tiga kali) di awal dan di akhir blok.\n# Ini adalah komentar baris tunggal\n\"\"\"\nIni adalah komentar multiline\n\"\"\"\n# Komentar adalah cara yang baik untuk menjelaskan kode.\nVariabel\nPython adalah bahasa dinamis dan oleh karena itu Anda tidak perlu menentukan jenis variabel seperti dalam C/C++. Variabel bisa dianggap sebagai wadah nilai. Nilai tersebut bisa berupa bilangan bulat, float, string, daftar, tuple, kamus, set, dll.\na = 1\na = 10.0\na = 'hello'\nDalam contoh di atas nilai bilangan bulat 1, nilai float 10.0, dan nilai string hello untuk semua kasus disimpan dalam variabel yang sama. Namun, hanya nilai yang terakhir ditugaskan yang merupakan nilai saat ini untuk a.\nOperator\nPython mendukung semua operator aritmatika umum seperti +, —, *, /. Juga mendukung operator perbandingan umum seperti &gt;, &lt;, ==, ! =, &gt;=, &lt;=, dll. Selain itu, melalui berbagai modul Python menyediakan banyak operator untuk melakukan operasi trigonometri, matematika, geometri, dll.\nLoop\nKonstruksi looping yang paling umum dalam Python adalah pernyataan for-loop, yang memungkinkan iterasi melalui kumpulan objek. Berikut ini adalah contohnya:\nfor i in range(1,5): \n    print(i)\nDalam contoh di atas output dari for-loop adalah angka dari 1 hingga 5. Fungsi range memungkinkan kita untuk membuat nilai mulai dari 1 dan berakhir dengan 5. Konsep semacam ini mirip dengan for-loop yang biasanya ditemukan dalam C/C++ atau sebagian besar bahasa pemrograman.\nKekuatan sebenarnya dari for-loop terletak pada kemampuannya untuk melakukan iterasi melalui objek Python lainnya seperti daftar, kamus, set, string, dll. Kami akan membahas objek Python ini secara lebih detail nanti.\na = ['python', 'scipy'] \nfor i in a:\n    print(i)\nDalam program di atas, for-loop melakukan iterasi melalui setiap elemen dari daftar dan mencetaknya.\nDalam program berikutnya, isi dari kamus dicetak menggunakan for-loop. Kamus dengan dua kunci lang dan ver didefinisikan. Kemudian, menggunakan for-loop, berbagai kunci diiterasi dan nilai yang sesuai dicetak.\na = {\n'lang':'python',\n'ver': '3.11.3'\n}\nfor key in a:\n    print(a[key])\nDiskusi tentang penggunaan for-loop untuk melakukan iterasi melalui berbagai baris dalam file teks, seperti file nilai yang dipisahkan koma, ditunda hingga bagian berikutnya.\nPernyataan if-else\nIf-else adalah pernyataan kondisional yang populer dalam semua bahasa pemrograman termasuk Python. Pernyataan if-else tidak harus menggunakan operator kondisional seperti &lt;, &gt;, ==, dll. Contoh pernyataan if-elif-else ditunjukkan di bawah ini.\nif a&lt;10:\n    print('a kurang dari 10')\nelif a&lt;20:\n    print('a antara 10 dan 20') \nelse:\n    print('a lebih dari 20')\nMisalnya, pernyataan if berikut ini legal dalam Python. Pernyataan if ini memeriksa kondisi bahwa daftar d tidak kosong.\nd = [ ]\nif d:\n    print('d tidak kosong')\nelse:\n    print('d kosong')\nDalam kode di atas, karena d kosong, klausa else benar dan kita memasuki blok else dan mencetak d kosong.\n\nStruktur Data\nKekuatan nyata Python terletak pada penggunaan liberal struktur datanya. Kritik umum terhadap Python adalah bahwa itu lambat dibandingkan dengan C/C++. Hal ini terutama benar jika for-loop digunakan dalam pemrograman Python. Ini dapat diredakan dengan penggunaan yang tepat dari struktur data seperti daftar, tuple, kamus dan set. Kami mendeskripsikan masing-masing struktur data ini dalam bagian ini.\nDaftar (lists)\nDaftar mirip dengan array di C/C++. Tetapi, tidak seperti array di C/C++, daftar dalam Python dapat menampung objek dari jenis apa pun seperti int, float, string dan termasuk daftar lainnya. Daftar dapat diubah ukurannya, karena ukurannya dapat diubah dengan menambahkan atau menghapus elemen. Contoh berikut akan membantu menunjukkan kekuatan dan fleksibilitas daftar.\na = ['python','scipy', 3.6]\na.pop(-1)\nprint(a)\n# Output: ['python','scipy']\n\na.append('numpy')\nprint(a)\n# Output: ['python','scipy' , 'numpy']\n\nprint(a[0])\n# Output: python\n\nprint(a[-1])\n# Output: numpy\n\nprint(a[0:2])\n# Output: ['python','scipy']\nDi baris pertama, daftar baru dibuat. Daftar ini berisi dua string dan satu angka float. Di baris kedua, kita menggunakan fungsi pop untuk menghapus elemen terakhir (indeks = —1). Elemen yang di-pop dicetak ke terminal. Setelah pop, daftar hanya berisi dua elemen daripada tiga asli. Kami menggunakan append, dan memasukkan elemen baru, “numpy” ke akhir daftar. Akhirnya, dalam dua perintah berikutnya kita mencetak nilai daftar di indeks 0 dan posisi terakhir yang ditunjukkan dengan menggunakan “—1” sebagai indeks. Dalam perintah terakhir, kami memperkenalkan slicing dan mendapatkan daftar baru yang hanya berisi dua nilai pertama dari daftar. Hal ini menunjukkan bahwa kita dapat mengoperasikan daftar menggunakan metode seperti pop, insert, atau remove dan juga menggunakan operator seperti slicing.\nDaftar dapat berisi daftar lain. Berikut adalah contohnya. Kami akan mempertimbangkan kasus daftar yang berisi empat angka dan diatur untuk terlihat seperti matriks.\na = [[1,2] , [3,4]]\nprint(a[0])\n# Output: [1,2]\n\nprint(a[1])\n# Output: [3,4]\n\nprint(a[0][0])\n# Output: 1\nDi baris 1, kami mendefinisikan daftar dari daftar. Nilai [1,2] ada dalam daftar pertama dan nilai [3,4] ada dalam daftar kedua. Kedua daftar dikombinasikan untuk membentuk daftar 2D. Di baris kedua, kami mencetak nilai elemen pertama dari daftar. Perhatikan bahwa ini mencetak baris pertama atau daftar pertama dan bukan hanya sel pertama. Di baris keempat, kami mencetak nilai baris kedua atau daftar kedua. Untuk mendapatkan nilai elemen pertama dalam daftar pertama, kita perlu mengindeks daftar seperti yang diberikan pada baris 6. Seperti yang Anda lihat, pengindeksan berbagai elemen dari daftar seolah-olah memanggil lokasi elemen dalam daftar.\nMeskipun elemen daftar dapat dioperasikan secara individual, kekuatan Python terletak pada kemampuannya untuk mengoperasikan seluruh daftar sekaligus menggunakan metode daftar dan pemahaman daftar.\nFungsi/Metode Daftar\nMari kita pertimbangkan daftar yang kami buat di bagian sebelumnya. Kami dapat mengurutkan daftar menggunakan metode sort seperti yang ditunjukkan di baris 2. Metode sort tidak mengembalikan daftar; sebaliknya, itu memodifikasi daftar saat ini. Oleh karena itu daftar yang ada akan berisi elemen dalam urutan yang diurutkan. Anda dapat melihat bahwa dalam kode berikut.\na = ['python', 'numpy', 'scipy']\na.sort()\nprint(a)\n# Output: ['numpy', 'python', 'scipy']\nDalam kode di atas, metode sort adalah cara mengurutkan daftar. Karena metode ini adalah metode inplace, daftar yang ada diubah, dan tidak ada nilai yang dikembalikan. Jadi, setelah perintah sort, a diubah menjadi daftar urutan.\nPemahaman daftar(List Comprehention)\nPemahaman daftar adalah fitur Python yang sangat kuat dan merupakan cara yang efisien untuk mengoperasikan daftar. Anda dapat membuat daftar baru dari daftar yang ada dengan pemahaman daftar. Sebagai contoh, mari kita ambil daftar dan kita ingin menghasilkan daftar baru yang mengandung semua angka dari daftar asli yang lebih besar dari 5. Dalam bahasa pemrograman lainnya kita akan menggunakan for-loop dan memeriksa setiap elemen satu per satu untuk melihat apakah itu lebih besar dari 5. Namun, dalam Python kita bisa menggunakan pemahaman daftar dan mendapatkan daftar baru dalam satu baris kode.\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nb = [i for i in a if i &gt; 5]\nprint(b)\n# Output: [6, 7, 8, 9]\nDalam kode di atas, variabel b merupakan daftar baru yang dibuat dari daftar a. Nilai i dalam daftar a ditambahkan ke b hanya jika i lebih besar dari 5. Jadi, Python adalah bahasa yang sangat kuat dan memiliki banyak fitur yang memungkinkan pengguna untuk menulis kode yang ringkas dan efisien. Python memudahkan pembacaan dan pemahaman kode dengan perintah sederhana dan jelas yang menggunakan sintaks alami. Struktur data Python, seperti daftar, memungkinkan manipulasi data yang efisien dan fleksibel.\nTuples\nTuples sangat mirip dengan list kecuali bahwa mereka tidak dapat diubah, yaitu, panjang dan isi tuple tidak dapat diubah saat runtime. Secara sintaksis, list menggunakan [ ] sedangkan tuples menggunakan ( ). Sama seperti list, tuple mungkin berisi jenis data apa pun termasuk tuple lain. Berikut adalah beberapa contoh:\na = (1,2,3,4)\nprint(a)\n# Output: (1,2,3,4)\n\nb = (3,)\nc = ((1,2),(3,4))\nSets\nSet adalah kumpulan objek unik yang tidak berurutan. Untuk membuat set, kita perlu menggunakan fungsi set atau operator {}. Berikut beberapa contohnya:\ns1 = set([1,2,3,4])\ns2 = set((1,1,3,4))\nprint(s2)\n# Output: {1,3,4}\nDictionaries\nDictionaries menyimpan pasangan kunci-nilai. Sebuah kamus dibuat dengan mengapit pasangan kunci-nilai di dalam { }.\na = {\n'lang' : 'python', \n'ver': '3.11.3'\n}\n\n\nPenanganan File\nPython menyediakan kemampuan untuk membaca dan menulis file. Ia juga memiliki fungsi, metode, dan modul untuk membaca format khusus seperti file nilai yang dipisahkan dengan koma (csv), format Microsoft Excel (xls), dll. Kami akan melihat setiap metode dalam bagian ini.\nMembaca file CSV\nBerikut adalah kode yang membaca file csv sebagai file teks.\nfo = open('myfile.csv')\nfor i in fo.readlines():\n    print(i)\nfo.close()\nSebagai alternatif dari membaca file csv sebagai file teks, kita dapat menggunakan modul csv.\nimport csv\nfor i in csv.reader(open('myfile.csv')):\n    print(i)\nMembaca file Excel File Microsoft Excel dapat dibaca dan ditulis menggunakan modul openpyxl.\nfrom openpyxl import load_workbook \nwb = load_workbook('myfile.xlsx') \nfor sheet in wb:\n    for row in sheet.values:\n        for col in row:\n            print(col, end=' | ') \n        print()\n\n\nFungsi yang Ditentukan Pengguna\nFungsi adalah bagian kode yang dapat digunakan kembali yang mungkin mengambil input dan mungkin atau tidak mengembalikan output. Berikut adalah contoh:\nimport math\ndef circleproperties(r):\n    area = math.pi*r*r\n    circumference = 2*math.pi*r\n    return area, circumference\n\na, c = circleproperties(5) # Radius of the circle is 5 \nprint('Area and Circumference of the circle are', a, c)\nFungsi circleproperties menerima satu argumen input, radius (r). Pernyataan return pada akhir definisi fungsi mengembalikan nilai yang dihitung (dalam hal ini, area dan keliling) ke fungsi pemanggil. Untuk memanggil fungsi, gunakan nama fungsi dan berikan nilai radius sebagai argumen yang dibungkus dalam tanda kurung. Akhirnya, area dan keliling lingkaran ditampilkan menggunakan panggilan fungsi print."
  },
  {
    "objectID": "2_Python.html#b.-komputasi-menggunakan-module-python",
    "href": "2_Python.html#b.-komputasi-menggunakan-module-python",
    "title": "Modul 2. Python",
    "section": "B. Komputasi Menggunakan Module Python",
    "text": "B. Komputasi Menggunakan Module Python\nDiketahui bahwa Python dilengkapi dengan berbagai modul bawaan. Modul-modul ini melakukan berbagai operasi khusus, mulai dari komputasi, manajemen database, hingga fungsi server web. Mengingat fokus buku ini adalah pembuatan aplikasi ilmiah, pembahasan dibatasi pada modul Python yang memungkinkan komputasi seperti scipy, numpy, matplotlib, Python Imaging Library (PIL), dan paket scikit. Relevansi masing-masing modul ini dijelaskan dan ditunjukkan penggunaannya dengan contoh. Pembahasan juga mencakup pembuatan modul Python baru.\n\nModul Python\nAda sejumlah modul Python ilmiah yang telah dibuat dan tersedia dalam distribusi Python. Beberapa modul paling populer yang relevan adalah:\n\nNumpy: Sebuah perpustakaan yang kuat untuk manipulasi array dan matriks.\n\nScipy: Menyediakan fungsi untuk melakukan operasi matematika tingkat tinggi seperti filtering, analisis statistik, pemrosesan gambar, dll.\n\nMatplotlib: Menyediakan fungsi untuk plotting dan bentuk visualisasi lainnya.\n\nPython Imaging Library: Menyediakan fungsi untuk pembacaan gambar dasar, penulisan dan pemrosesan.\n\nScikits: Sebuah paket tambahan untuk scipy. Modul dalam scikit dimaksudkan untuk ditambahkan ke scipy setelah pengembangan.\n\nMembuat Modul\nModul adalah file Python yang berisi beberapa fungsi atau kelas dan komponen opsional lainnya. Semua fungsi dan kelas ini berbagi namespace yang sama, yaitu, nama file modul. Sebagai contoh, program berikut adalah modul Python yang valid.\n# nama file: examplemodules.py\nversion = '1.0'\ndef printpi():\n    print('Nilai pi adalah 3.1415')\nSebuah fungsi bernama ‘printpi’ dan variabel yang disebut ‘version’ dibuat dalam modul ini. Fungsi ini melakukan operasi sederhana untuk mencetak nilai pi.\nMemuat Modul\nUntuk memuat modul ini, gunakan perintah berikut di baris perintah Python atau dalam program Python. Kata “examplemodules” adalah nama file modul.\nimport examplemodules\nSetelah modul dimuat, fungsi dapat dijalankan menggunakan perintah di bawah. Perintah pertama mencetak nilai pi bersama dengan label, sementara perintah kedua mencetak nomor versi.\nexamplemodules.printpi()\n# Nilai pi adalah 3.1415\n\nexamplemodules.version\n# 1.0\nModul contoh yang ditunjukkan di atas hanya memiliki satu fungsi. Sebuah modul mungkin berisi beberapa fungsi atau kelas. Dalam contoh pertama, modul datetime dimuat. Namun dalam contoh ini, hanya tertarik untuk mendapatkan tanggal saat ini menggunakan date.today().\nimport datetime\nprint(datetime.date.today()) # 2023-07-31\nDalam contoh kedua, hanya fungsi yang diperlukan (date) dalam modul datetime yang dimuat. Untuk modul besar, disarankan untuk mengimpor hanya fungsi yang diperlukan agar kode lebih mudah dibaca.\nfrom datetime import date\nprint (date.today()) # 2023-07-31\nDalam contoh ketiga, mengimpor semua fungsi dalam modul yang diberikan menggunakan *. Setelah diimpor, nama file (dalam hal ini “date”) yang berisi fungsi (dalam hal ini “today()”) perlu ditentukan. Metode impor ini biasanya tidak disarankan, karena dapat menghasilkan tabrakan namespace. Misalnya, menjadi ambigu jika fungsi date ada di modul datetime atau dari pernyataan impor lainnya.\nfrom datetime import * \nprint(date.today()) # 2023-07-31\nDalam contoh keempat, mengimpor modul (dalam hal ini numpy) dan menggantinya dengan sesuatu yang lebih pendek seperti np. Ini dikenal sebagai aliasing. Ini akan mengurangi jumlah karakter yang perlu diketik dan akibatnya baris kode yang perlu dipertahankan.\nimport numpy as np »&gt; np.ones( [3,3] )\narray([[ 1., 1. , 1.],\n           [ 1., 1. , 1.],\n           [ 1., 1. , 1.]])  \n\n\nNumPy\nModul numpy menambahkan kemampuan untuk memanipulasi array dan matriks menggunakan kumpulan fungsi matematika. Numpy berasal dari modul yang sudah tidak digunakan lagi, yaitu Numeric dan Numarray. Numeric adalah upaya pertama untuk menyediakan kemampuan memanipulasi array, tetapi sangat lambat dalam melakukan komputasi pada array yang besar. Numarray, di sisi lain, terlalu lambat dalam mengolah array yang kecil. Kode dasar kedua modul ini digabungkan untuk membuat numpy. Numpy memiliki fungsi dan rutinitas untuk melakukan aljabar linear, pengambilan sampel acak, polinomial, fungsi keuangan, operasi himpunan, dan lain-lain. Karena buku ini berfokus pada pemrosesan gambar dan karena gambar merupakan array, kita akan menggunakan kemampuan manipulasi matriks numpy.\nArray atau Matriks Numpy?\nNumpy memanipulasi matriks matematika dan vektor, sehingga menghitung lebih cepat daripada penggunaan loop tradisional yang memanipulasi skalar. Dalam numpy, terdapat dua jenis kelas matriks matematika: array dan matriks. Kedua kelas tersebut dirancang untuk tujuan serupa, tetapi array lebih umum dan memiliki dimensi n, sedangkan matriks memfasilitasi perhitungan aljabar linear yang lebih cepat. Beberapa perbedaan antara array dan matriks dijelaskan di bawah ini:\n\nObjek matriks memiliki rank 2, sedangkan array memiliki rank &gt; 2.\n\nObjek matriks dapat dikalikan menggunakan operator *, sedangkan operator yang sama pada array melakukan perkalian elemen-demi-elemen. Fungsi dot() harus digunakan untuk melakukan perkalian pada array.\n\nArray adalah tipe data default di numpy.\nArray lebih sering digunakan dalam numpy dan modul-modul lain yang menggunakan numpy untuk komputasi mereka. Matriks dan array dapat saling dipertukarkan, tetapi disarankan untuk menggunakan array.\n\nInstalasi NumPy\n! pip install numpy\nMenggunakan Library Numpy\nimport numpy as np\n\n\nSciPy\nScipy adalah sebuah perpustakaan fungsi, program, dan alat matematika untuk pemrograman ilmiah dalam bahasa Python. Scipy menggunakan numpy untuk komputasi internalnya. Scipy adalah perpustakaan yang luas yang memungkinkan pemrograman berbagai aplikasi matematika seperti integrasi, optimisasi, transformasi Fourier, pemrosesan sinyal, statistik, pemrosesan gambar multidimensi, dan lain-lain. Travis Oliphant, Eric Jones, dan Pearu Peterson menggabungkan modul-modul mereka untuk membentuk scipy pada tahun 2001. Sejak saat itu, banyak sukarelawan di seluruh dunia telah berpartisipasi dalam pemeliharaan scipy.\nScipy memuat modul dapat memakan banyak sumber daya CPU dan memori. Hal ini terutama berlaku untuk paket-paket besar seperti scipy yang mengandung banyak submodul. Dalam kasus seperti itu, muat hanya submodul yang spesifik.\nInstallasi SciPy\n! pip install scipy\nMenggunakan Library Scipy\nfrom scipy import ndimage\nimport scipy.ndimage as im\nPada perintah pertama, hanya submodul ndimage yang dimuat. Pada perintah kedua, modul ndimage dimuat sebagai im.\n\n\nMatplotlib\nMatplotlib adalah perpustakaan plot 2D/3D untuk Python. Ia dirancang untuk menggunakan tipe data numpy. Matplotlib dapat digunakan untuk menghasilkan plot di dalam program Python. Contoh yang menunjukkan fitur-fitur matplotlib ditunjukkan dalam Gambar 2.1.\n\n\n\nGambar 2.1 Ilustrasi Matplotlib\n\n\nInstalasi Matplotlib\n! pip install matplotlib\nMenggunakan Library Matplotlib\nimport matplotlib\n\n\nPython Image Library (PIL)\nPython Imaging Library (PIL) adalah modul untuk membaca, menulis, dan memproses file gambar. Modul ini mendukung sebagian besar format gambar umum seperti JPEG, PNG, TIFF, dll. Namun, sejak versi Python 3.0, PIL tidak lagi dikembangkan dan digantikan oleh library yang disebut Pillow.\nInstallasi Pillow\n! pip install Pillow\nMenggunakan Library Pillow\nfrom PIL import image\n\n\nScikits\nScikits adalah singkatan dari scipy toolkits. Ini adalah paket tambahan yang dapat digunakan bersama dengan alat-alat scipy. Sebuah algoritma diprogram dalam scikits jika:\n- Algoritma tersebut masih dalam pengembangan dan belum siap untuk digunakan secara luas dalam scipy.\n- Paket tersebut memiliki lisensi yang tidak kompatibel dengan scipy.\n- Scipy adalah paket ilmiah umum dalam bahasa Python. Oleh karena itu, dirancang agar dapat diterapkan dalam berbagai bidang. Jika sebuah paket dianggap khusus untuk bidang tertentu, maka paket tersebut tetap menjadi bagian dari scikits.\nScikits terdiri dari modul-modul dari berbagai bidang seperti ilmu lingkungan, analisis statistik, pemrosesan gambar, rekayasa mikrowave, pemrosesan audio, masalah nilai batas, penyesuaian kurva, komputasi kuantum, dll.\nDalam buku ini, kita akan fokus hanya pada rutinitas pemrosesan gambar dalam scikits yang disebut scikit-image. Rutinitas scikit-image ini berisi algoritma-algoritma untuk input/output, morfologi, deteksi dan analisis objek, dll.\nInstallasi Skimage\n! pip install scikit-image\nPenggunaan Library Skimage\nfrom skimage import filters\nimport skimage.filters as fi\nPada perintah pertama, hanya submodul filters yang dimuat. Pada perintah kedua, modul filters dimuat sebagai fi.\n\n\nModul Python OpenCV\nOpen Source Computer Vision Library (OpenCV) [Ope20a] adalah perpustakaan perangkat lunak untuk pemrosesan gambar, penglihatan komputer, dan pembelajaran mesin. Ini memiliki lebih dari 2000 algoritma untuk memproses data gambar. OpenCV memiliki basis pengguna yang besar dan digunakan secara luas di lembaga akademik, organisasi komersial, dan lembaga pemerintah. Perpustakaan ini menyediakan ikatan (binding) untuk bahasa pemrograman umum seperti C, C++, Python, dll.\nInstallasi Opencv\n! pip install opencv-python\nMenggunakan Library OpenCV\nimport cv2"
  },
  {
    "objectID": "3_Dasar_dasar_Image_Processing.html#a.-pengenalan-image-processing",
    "href": "3_Dasar_dasar_Image_Processing.html#a.-pengenalan-image-processing",
    "title": "Modul 3. Dasar-dasar Image Processing",
    "section": "A. Pengenalan Image Processing",
    "text": "A. Pengenalan Image Processing\nManusia mengandalkan penglihatan mereka untuk tugas-tugas mulai dari pengenalan pola hingga naluri bertahan hidup. Kemampuan manusia untuk melakukan analisis yang kompleks dan rinci terhadap suatu karya seni berdasarkan input visual adalah sesuatu yang luar biasa. Namun, sejauh mana manusia dapat melakukan apa yang komputer lakukan dengan sangat cepat masih perlu diteliti.\nKebutuhan untuk mengekstrak informasi dari citra dan menginterpretasikan isinya telah menjadi salah satu faktor pendorong dalam perkembangan pemrosesan citra dan visi komputer selama beberapa dekade terakhir. Aplikasi pemrosesan citra meliputi berbagai aktivitas manusia, antara lain:\n\nAplikasi medis: Modalitas pencitraan diagnostik seperti radiografi digital, PET (tomografi emisi positron), CT (tomografi aksial komputer), MRI (pemindaian resonansi magnetik), dan fMRI (pemindaian resonansi magnetik fungsional) telah diadopsi secara luas oleh komunitas medis.\n\nAplikasi industri: Sistem pemrosesan citra telah berhasil digunakan dalam sistem manufaktur untuk berbagai tugas, seperti sistem keamanan, kontrol kualitas, dan pengendalian kendaraan berpemandu otomatis (AGVs).\n\nAplikasi militer: Skenario yang paling menantang dan kritis dalam hal kinerja pemrosesan citra adalah untuk mendukung tugas militer, mulai dari deteksi tentara atau kendaraan hingga panduan rudal dan pengenalan objek dan tugas pengintaian menggunakan kendaraan udara tak berawak atau UAV. Selain itu, aplikasi militer sering kali membutuhkan penggunaan sensor pendeteksi yang khusus, seperti kamera jarak dan kamera inframerah yang melihat ke depan.\nPenegakan hukum dan keamanan: Pengawasan adalah salah satu bidang yang banyak diteliti dalam komunitas pemrosesan video.\n\nTeknologi biometrik (seperti pengenalan sidik jari, wajah, iris, dan telapak tangan) telah menjadi subjek penelitian dalam pemrosesan citra selama lebih dari satu dekade dan kini telah digunakan secara komersial.\n\nElektronik konsumen: Kamera digital dan camcorder, dengan kemampuan pemrosesan yang canggih, telah membuat film dan teknologi pita analog menjadi usang. Paket perangkat lunak untuk meningkatkan, mengedit, mengatur, dan mempublikasikan citra dan video telah maju pesat dalam kompleksitasnya sambil tetap menjaga antarmuka yang ramah pengguna. TV berdefinisi tinggi, monitor, pemutar DVD, dan pemutar video pribadi (PVR) semakin meningkat popularitasnya karena harga yang terjangkau. Perkembangan jaringan dan distribusi juga telah berhasil membuat terobosan dalam perangkat lain, seperti personal digital assistants (PDA), ponsel, dan pemutar musik portabel (MP3).\n\nInternet, khususnya World Wide Web: Ada banyak informasi visual yang tersedia di web. Kolaborasi dalam mengunggah, berbagi, dan memberi anotasi (tagging) pada video semakin populer. Menemukan dan mengambil citra dan video di web berdasarkan isinya tetap menjadi tantangan terbuka dalam penelitian."
  },
  {
    "objectID": "3_Dasar_dasar_Image_Processing.html#b.-konsep-dasar-image-processing",
    "href": "3_Dasar_dasar_Image_Processing.html#b.-konsep-dasar-image-processing",
    "title": "Modul 3. Dasar-dasar Image Processing",
    "section": "B. Konsep Dasar Image Processing",
    "text": "B. Konsep Dasar Image Processing\nSebuah gambar digital merupakan larik 2D dari angka-angka yang mewakili versi sampel dari sebuah gambar. Gambar didefinisikan dalam bentuk grid, setiap lokasi grid disebut piksel. Sebuah gambar direpresentasikan oleh grid yang terbatas dan setiap nilai intensitas direpresentasikan oleh sejumlah bit yang terbatas. M x N pada gambar f(x, y) didefinisikan sebagai:\n\n\n\n\n\n\n\n\n\n\nDalam representasi ini, digunakan [0, L — 1] jumlah tingkat intensitas untuk mewakili semua nilai piksel grayscale, dan k jumlah bit digunakan untuk mewakili setiap tingkat intensitas, yaitu, L = 2k. Jadi, jumlah bit yang diperlukan untuk menyimpan gambar M x N adalah M x N x k. Kecerahan sebuah gambar merujuk pada tingkat keseluruhan cahaya atau kegelapan gambar, sementara kontras adalah perbedaan antara intensitas piksel maksimum dan minimum dalam sebuah gambar. Kecerahan dapat meningkat atau dikurangi dengan penambahan atau pengurangan sederhana pada nilai piksel.\nSebuah gambar biner direpresentasikan oleh hanya satu bit. Di sisi lain, gambar grayscale direpresentasikan oleh 8 bit. Sebuah gambar raster adalah kumpulan titik-titik, yang disebut piksel. Sebuah gambar vektor adalah kumpulan garis dan kurva yang terhubung, dan digunakan untuk menghasilkan objek.\nSebuah gambar adalah fungsi f, dari ruang R2 ke ruang R. Sebuah gambar direpresentasikan oleh f(x.y’), dan itu menunjukkan intensitas di posisi (x,y). Oleh karena itu, sebuah gambar hanya didefinisikan pada sebuah persegi panjang, dengan rentang yang terbatas, yaitu,\n\nGambar berwarna memiliki komponen Merah (R), Hijau (G), dan Biru (B). Masing-masing dari ketiga komponen R, G, B biasanya direpresentasikan oleh 8 bit, dan oleh karena itu dibutuhkan 24-bit untuk sebuah gambar berwarna. Tiga warna primer ini dicampur dalam proporsi yang berbeda untuk mendapatkan warna-warna yang berbeda. Untuk berbagai aplikasi pengolahan gambar, format RGB, HIS, YIQ, YCbCr, dll. digunakan. Sebuah gambar berwarna adalah fungsi tiga komponen, yang merupakan fungsi “nilai-vektor”, dan direpresentasikan sebagai berikut:\n\nGambar terindeks memiliki peta warna yang terkait, yang merupakan daftar dari semua warna yang digunakan dalam gambar tersebut. Contoh dari format ini adalah gambar PNG dan GIF. Jadi, berbagai jenis gambar digital dapat dijelaskan sebagai berikut.\n\nGambar biner - 1 bit/pixel\nGambar grayscale - 8 bit/pixel\nGambar warna asli atau RGB - 24 bit/pixel\nGambar terindeks - 8 bit/pixel\n\nResolusi spasial sebuah gambar mendefinisikan jumlah piksel yang digunakan untuk mencakup ruang visual yang ditangkap oleh gambar tersebut. Resolusi intensitas sebuah gambar bergantung pada jumlah bit yang digunakan untuk mewakili nilai intensitas yang berbeda. Jumlah gambar atau frame video yang ditangkap oleh kamera dalam waktu tertentu menentukan resolusi temporal. Kurangnya jumlah tingkat intensitas (resolusi intensitas rendah) di area halus sebuah gambar menghasilkan “efek kontur palsu”, yaitu, menciptakan tepi atau garis palsu di mana aslinya tidak ada. Juga “efek kotak-kotak” terjadi ketika resolusi spasial sebuah gambar sangat rendah.\nPengolahan gambar digital berurusan dengan manipulasi dan analisis gambar digital oleh sistem digital. Sebuah operasi pengolahan gambar biasanya mendefinisikan gambar baru g dalam hal gambar masukan f. Seperti yang ditunjukkan dalam Gambar 2.1, kita dapat mengubah rentang f menjadi g(x, y) = t(f(x,y)), atau kita dapat mengubah domain f menjadi g(x,y) = f(tx(x,y),ty(x,y)). Nilai piksel dimodifikasi dalam transformasi pertama (Gambar 2.1(a)); sedangkan posisi piksel spasial berubah dalam transformasi kedua (Gambar 2.1(b)). Domain sebuah gambar dapat diubah dengan memutar dan menyesuaikan skala gambar seperti yang diilustrasikan dalam Gambar 2.2.\n\n\n\n\nMengubah Rentang Gambar\n\n\n\n\n\n\n\nMengubah Domain dari Suatu Gambar"
  },
  {
    "objectID": "3_Dasar_dasar_Image_Processing.html#c.-python-untuk-image-processing",
    "href": "3_Dasar_dasar_Image_Processing.html#c.-python-untuk-image-processing",
    "title": "Modul 3. Dasar-dasar Image Processing",
    "section": "C. Python Untuk Image Processing",
    "text": "C. Python Untuk Image Processing\nDalam tutorial ini, Anda akan menemukan fungsi dasar untuk memuat, memanipulasi, dan menampilkan gambar. Informasi utama dari gambar akan diperoleh, seperti ukuran, jumlah saluran, kelas penyimpanan, dan lain-lain. Setelah itu, Anda akan dapat melakukan filter klasik pertama Anda.\nProses yang berbeda akan dilakukan pada gambar-gambar berikut ini:\n\n\nSpatial Filter\n\nFiltering\nSeperti halnya filter air yang menghilangkan kotoran, filter pemrosesan gambar menghapus fitur yang tidak diinginkan (seperti noise) dari sebuah gambar. Setiap filter memiliki utilitas khusus dan dirancang untuk menghilangkan jenis noise tertentu atau meningkatkan aspek tertentu dari gambar. Kami akan membahas banyak filter beserta tujuan dan efek mereka pada gambar.\nUntuk melakukan filtering, digunakan filter atau masker. Biasanya, ini berupa jendela persegi dua dimensi yang bergerak melintasi gambar hanya mempengaruhi satu piksel pada satu waktu. Setiap angka dalam filter dikenal sebagai koefisien. Koefisien dalam filter menentukan efek dari filter dan akibatnya gambar keluaran. Mari kita pertimbangkan filter 3x3, F, yang diberikan dalam Tabel 4.1.\n\nJika (i, j) adalah piksel dalam gambar, maka sub-gambar di sekitar (i, j) dengan dimensi yang sama dengan filter akan dipertimbangkan untuk filtering. Pusat filter ditempatkan agar tumpang tindih dengan (i, j). Piksel-piksel dalam sub-gambar dikalikan dengan koefisien yang sesuai dalam filter. Hal ini menghasilkan matriks dengan ukuran yang sama dengan filter. Matriks ini disederhanakan menggunakan persamaan matematika untuk mendapatkan satu nilai yang akan menggantikan nilai piksel pada (i, j) dalam gambar. Persamaan matematika yang tepat tergantung pada jenis filter. Misalnya, dalam kasus filter rata-rata, nilai F adalah -7, di mana N adalah jumlah elemen dalam filter. Gambar yang difilter diperoleh dengan mengulangi proses penempatan filter pada setiap piksel dalam gambar, memperoleh satu nilai, dan menggantikan nilai piksel dalam gambar asli. Proses ini memindahkan jendela filter melintasi gambar disebut konvolusi dalam domain spasial.\nMari kita pertimbangkan sub-gambar berikut dari gambar I, yang berpusat pada (i, j).\n\n\n\nKonvolusi filter yang diberikan dalam Tabel 4.1 dengan sub-gambar dalam Tabel 4.2 diberikan sebagai berikut:\n\n\n\nDi mana Inew(i, j) adalah nilai keluaran pada lokasi (i, j). Proses ini harus diulang untuk setiap piksel dalam gambar. Karena filter memainkan peran penting dalam proses konvolusi, filter juga dikenal sebagai kernel konvolusi.\nOperasi konvolusi harus dilakukan pada setiap piksel dalam gambar, termasuk piksel di batas gambar. Ketika filter ditempatkan pada piksel batas, sebagian filter akan berada di luar batas gambar. Karena nilai piksel di luar batas tidak ada, nilai-nilai baru harus dibuat sebelum konvolusi. Proses ini untuk menciptakan nilai piksel di luar batas disebut padding. Piksel yang dipadatkan dapat diasumsikan nol atau nilai tetap. Pilihan padding lainnya seperti nearest neighbor atau reflect menciptakan piksel yang dipadatkan menggunakan nilai piksel dalam gambar. Dalam kasus nol, piksel yang dipadatkan semua bernilai nol. Dalam kasus konstan, piksel yang dipadatkan mengambil nilai spesifik. Dalam kasus reflect, piksel yang dipadatkan mengambil nilai dari baris atau kolom terakhir. Piksel yang dipadatkan hanya dipertimbangkan untuk konvolusi dan akan dibuang setelah konvolusi.\nMari kita pertimbangkan contoh untuk menunjukkan berbagai pilihan padding. Gambar 4.1(a) adalah gambar input berukuran 7x7 yang akan dikonvolusi menggunakan filter 3x5 dengan pusat filter di (1,2). Untuk memasukkan piksel batas dalam konvolusi, kita memasukkan gambar dengan satu baris di atas dan satu baris di bawah serta dua kolom di sebelah kiri dan dua kolom di sebelah kanan. Secara umum, ukuran filter menentukan jumlah baris dan kolom yang akan dipadatkan ke gambar.\n\nPadding dengan nol: Semua piksel yang dipadatkan diberi nilai nol (Gambar 4.1(b)).\nPadding dengan konstanta: Nilai konstan 5 digunakan untuk semua piksel yang dipadatkan (Gambar 4.1(c)). Nilai konstan dapat dipilih berdasarkan jenis gambar yang sedang diproses.\nNearest neighbor: Nilai dari baris atau kolom terakhir (Gambar 4.1(d)) digunakan untuk padding.\nReflect: Nilai dari baris atau kolom terakhir (Gambar 4.1(e)) dipantulkan melintasi batas gambar.\nWrap: Dalam opsi wrap seperti yang ditunjukkan dalam Gambar 4.1(f), baris pertama (atau kolom) setelah batas mengambil nilai yang sama dengan baris pertama (atau kolom) dalam gambar, dan seterusnya.\n\n\n\n\n\n\n\n\n7 x 7 input citra\n\n\n\n\n\n\n\nPadding dengan kosong\n\n\n\n\n\n\n\n\n\nPadding dengan nilai konstant\n\n\n\n\n\n\n\nPadding dengan nearest neighbors\n\n\n\n\n\n\n\n\n\nPadding dengan nearest neighbors\n\n\n\n\n\n\n\nPadding dengan wrap option\n\n\n\n\n\n\n\nShape Detection Filter\nFrangi Filter\nKegunaan dari Filter Frangi [AFFV98] yaitu mendeteksi objek yang mirip dengan pembuluh darah pada sebuah gambar. Sebelum membahas matematika dibaliknya, pembahasan akan dimulai dengan ide fundamental dari Frangi itu sendiri. Pada gambar x.x.x berisi dua objek, salah satu objek memanjang ke satu arah, akan tetapi tidak ke arah lainnya, sedangkan objek kedua berbentuk persegi. Secara proporsional, panah ortogonal digambar dimana panjangnya sepanjang suatu arah tertentu. Dengan mendapatkan nilai eigen dari kedua objek tersebut, maka kita dapat mengukur perbedaan geometri kualitatif ini. Objek yang memanjang, nilai eigennya akan lebih besar pada arah panah yang lebih panjang serta lebih kecil pada arah panah yang lebih pendek. Sedangkan objek persegi, nilai eigen pada arah panah yang lebih panjang serupa dengan nilai eigen pada arah panah yang lebih pendek. Filter Frangi menggunakan gambar turunan kedua (Hessian) sebagai dasar perhitungan nilai eigen, bukan menggunakan gambar asli. Turunan kedua atau Hessian merupakan representasi matematis dari perubahan intensitas piksel dalam gambar. Dengan menggunakan gambar turunan kedua, Filter Frangi dapat mengidentifikasi dan menghitung nilai eigen yang mencerminkan karakteristik objek mirip pembuluh darah dengan lebih baik daripada menggunakan gambar asli. Maka dari itu, penggunaan gambar turunan kedua memungkinkan Filter Frangi untuk memperoleh informasi yang lebih relevan dan memperbaiki kemampuan deteksi objek pembuluh darah.\n\n\n\n\nIlustrasi Frangi Filter\n\n\n\nNoise yang disebabkan oleh turunan dapat dikurangi menggunakan konvolusi dimana gambar akan dihaluskan. Pada konteks umum, metode yang digunakan adalah penghalusan Gaussian. Penghalusan Gaussian merupakan teknik pengolahan citra yang menggunakan filter Gaussian untuk mengurangi nois dan menyamarkan detail tajam pada gambar. Dalam buku ini akan ditunjukkan bahwa mencari turunan dari gambar yang dihaluskan dengan konvolusi Gaussian setara dengan mencari turunan dari Gaussian yang dikonvolusikan dengan gambar. Selanjutnya, kami akan menghitung turunan kedua dari Gaussian dengan menggunakan rumus berikut ini, di mana gσ merupakan fungsi Gaussian.\n\nSelanjutnya, menentukan turunan kedua lokal (Hessian) dan nilai eigen-nya. Untuk gambar 2D, setiap koordinat piksel akan memiliki dua nilai eigen (λ1 dan λ2). Kemudian, nilai eigen diurutkan dalam urutan meningkat. Sebuah piksel dianggap sebagai bagian dari struktur tabung atau mirip pembuluh darah jika λ1 ≈ 0 dan |λ2| &gt; |λ1|. Sedangkan untuk citra 3D, setiap koordinat voxel akan memiliki tiga nilai eigen (λ1, λ2, dan λ3). Nilai eigen tersebut kemudian diurutkan dalam urutan meningkat. Sebuah voxel dianggap sebagai bagian dari struktur tabung atau mirip pembuluh darah jika λ1 ≈ 0 sementara λ2 dan λ3 memiliki nilai absolut yang tinggi yang hampir sama dan memiliki tanda yang sama. Pembuluh yang terlihat terang akan memiliki nilai positif untuk λ2 dan λ3, sedangkan pembuluh yang lebih gelap akan memiliki nilai negatif untuk λ2 dan λ3."
  },
  {
    "objectID": "3_Dasar_dasar_Image_Processing.html#rangkuman",
    "href": "3_Dasar_dasar_Image_Processing.html#rangkuman",
    "title": "Modul 3. Dasar-dasar Image Processing",
    "section": "Rangkuman",
    "text": "Rangkuman\n\nFilter rata-rata menghaluskan gambar sambil mengaburkan bagian tepi dalam gambar.\nFilter median efektif dalam menghilangkan noise salt-and-pepper.\nFilter turunan pertama yang paling banyak digunakan adalah Sobel, Prewitt, dan Canny.\nBaik Laplacian maupun LoG adalah filter turunan kedua yang populer. Laplacian sangat sensitif terhadap noise. Pada LoG, Gaussian menghaluskan gambar sehingga noise dari Laplacian dapat dikompensasi. Namun, LoG mengalami efek ‘spaghetti’. (*Efek ‘spaghetti’ merujuk pada hasil filter LoG yang menghasilkan garis-garis tipis seperti spageti yang melintang di sekitar tepi objek dalam gambar. Efek ini terjadi karena penggunaan kernel LoG yang besar atau parameter yang tidak sesuai, yang mengakibatkan respons yang berlebihan dan menciptakan garis-garis halus yang terlalu banyak pada tepi objek dalam gambar. Hasilnya adalah gambar yang terdistorsi dan sulit diinterpretasikan dengan jelas)\nFilter Frangi digunakan untuk mendeteksi struktur yang mirip dengan pembuluh darah."
  },
  {
    "objectID": "3_Dasar_dasar_Image_Processing.html#latihan-praktik",
    "href": "3_Dasar_dasar_Image_Processing.html#latihan-praktik",
    "title": "Modul 3. Dasar-dasar Image Processing",
    "section": "Latihan Praktik",
    "text": "Latihan Praktik"
  },
  {
    "objectID": "Studi_Kasus.html",
    "href": "Studi_Kasus.html",
    "title": "Studi Kasus",
    "section": "",
    "text": "Latihan Praktik\nLatihan ini memandu Anda melalui langkah-langkah membuat sistem klasifikasi gambar sendiri dengan SIFT, BoVW, dan SVM. Anda akan:\n\nMemuat dan memproses dataset gambar Anda sendiri.\nMenerapkan metode SIFT pada gambar untuk mengekstrak fitur dan menggunakan BoVW untuk membentuk vektor fitur.\nMembuat dan melatih model SVM dan KNN Anda sendiri.\n\nMengevaluasi performa model Anda pada data pengujian.\n\nLatihan ini memberikan pemahaman yang lebih baik tentang bagaimana sistem klasifikasi gambar bekerja dengan menggunakan metode ekstraksi fitur dan model klasifikasi.\nEvaluasi Sistem\nEvaluasi sistem melibatkan perbandingan antara kelas sebenarnya dan kelas yang diprediksi oleh model.\n\nEvaluasi In-Sample: Selama proses pelatihan, akurasi pada data pelatihan akan dihitung.\n\nEvaluasi Out-of-Sample: Setelah model dilatih, akurasi pada data pengujian akan dihitung.\n\nKODE PYTHON\nimport cv2\nimport numpy as np\nimport os\n# Get the training classes names and store them in a list\n#Here we use folder names for class names\n\n#train_path = 'dataset/train'  # Names are Aeroplane, Bicycle, Car\ntrain_path = 'Dataset'  # Folder Names are Parasitized and Uninfected\ntraining_names = os.listdir(train_path)\n\n# Get path to all images and save them in a list\n# image_paths and the corresponding label in image_paths\nimage_paths = []\nimage_classes = []\nclass_id = 0\n\n#To make it easy to list all file names in a directory let us define a function\ndef imglist(path):    \n    return [os.path.join(path, f) for f in os.listdir(path)]\n\n#Fill the placeholder empty lists with image path, classes, and add class ID number\nfor training_name in training_names:\n    dir = os.path.join(train_path, training_name)\n    class_path = imglist(dir)\n    image_paths+=class_path\n    image_classes+=[class_id]*len(class_path)\n    class_id+=1\n\n# Create feature extraction and keypoint detector objects\n    #SIFT is not available anymore in openCV    \n# Create List where all the descriptors will be stored\ndes_list = []\n\n#BRISK is a good replacement to SIFT. ORB also works but didn;t work well for this example\nsift = cv2.SIFT_create(30)\n\nfor image_path in image_paths:\n    im = cv2.imread(image_path)\n    kpts, des = sift.detectAndCompute(im, None)\n    des_list.append((image_path, des))   \n    \n# Stack all the descriptors vertically in a numpy array\ndescriptors = des_list[0][1]\nfor image_path, descriptor in des_list[1:]:\n    descriptors = np.vstack((descriptors, descriptor))  \n\n#kmeans works only on float, so convert integers to float\ndescriptors_float = descriptors.astype(float)  \n\n# Perform k-means clustering and vector quantization\nfrom scipy.cluster.vq import kmeans, vq\n\nk = 150  #k means with 100 clusters gives lower accuracy for the aeroplane example\nvoc, variance = kmeans(descriptors_float, k, 1) \n\n# Calculate the histogram of features and represent them as vector\n#vq Assigns codes from a code book to observations.\nim_features = np.zeros((len(image_paths), k), \"float32\")\nfor i in range(len(image_paths)):\n    words, distance = vq(des_list[i][1],voc)\n    for w in words:\n        im_features[i][w] += 1\n\nfrom sklearn.model_selection import train_test_split\n# Membagi dataset menjadi data training dan data testing\nX_train, X_test, y_train, y_test = train_test_split(im_features, image_classes, test_size=0.2, random_state=42, stratify=image_classes)\n\n# Mencetak jumlah data pada setiap bagian (training dan testing)\nprint(\"Jumlah data training:\", len(X_train))"
  },
  {
    "objectID": "Studi_Kasus.html#kode-python",
    "href": "Studi_Kasus.html#kode-python",
    "title": "Studi Kasus",
    "section": "KODE PYTHON",
    "text": "KODE PYTHON\nMengimport Library yang dibutuhkan\nimport cv2\nimport numpy as np\nimport os\nfrom sklearn.model_selection import train_test_split\nMemuat Dataset\n\n\n\n\nStruktur Dataset\n\n\n\ntrain_path = 'Dataset'\ntraining_names = os.listdir(train_path) # Putri, Kirei, Yudha\n\nimage_paths = []\nimage_classes = []\nclass_id = 0\n\ndef imglist(path):    \n    return [os.path.join(path, f) for f in os.listdir(path)]\n\nfor training_name in training_names:\n    dir = os.path.join(train_path, training_name) # Menggabungkan train_path dan training_name; Dataset/Putri, Dataset/Kirei, Dataset/Yudha\n    class_path = imglist(dir)\n    image_paths+=class_path\n    image_classes+=[class_id]*len(class_path)\n    class_id+=1\n\n\n\n\n\n\nTip with Title\n\n\n\n\n\n\nMengekstrak Fitur Menggunakan Algoritma SIFT\ndes_list = []\n\nsift = cv2.SIFT_create(30)\n\nfor image_path in image_paths:\n    im = cv2.imread(image_path)\n    kpts, des = sift.detectAndCompute(im, None)\n    des_list.append((image_path, des))   \n    \ndescriptors = des_list[0][1]\nfor image_path, descriptor in des_list[1:]:\n    descriptors = np.vstack((descriptors, descriptor))  \n\ndescriptors_float = descriptors.astype(float)  \n\nfrom scipy.cluster.vq import kmeans, vq\n\nk = 150  \nvoc, variance = kmeans(descriptors_float, k, 1) \n\nim_features = np.zeros((len(image_paths), k), \"float32\")\nfor i in range(len(image_paths)):\n    words, distance = vq(des_list[i][1],voc)\n    for w in words:\n        im_features[i][w] += 1\n\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(im_features, image_classes, test_size=0.2, random_state=42, stratify=image_classes)\n\nprint(\"Jumlah data training:\", len(X_train))"
  },
  {
    "objectID": "Studi_Kasus.html#sistem-klasifikasi-gambar",
    "href": "Studi_Kasus.html#sistem-klasifikasi-gambar",
    "title": "Studi Kasus",
    "section": "Sistem Klasifikasi Gambar",
    "text": "Sistem Klasifikasi Gambar\nLatihan Praktik\nLatihan ini memandu Anda melalui langkah-langkah membuat sistem klasifikasi gambar sendiri dengan SIFT, BoVW, dan SVM. Anda akan:\n\nMemuat dan memproses dataset gambar Anda sendiri.\nMenerapkan metode SIFT pada gambar untuk mengekstrak fitur dan menggunakan BoVW untuk membentuk vektor fitur.\nMembuat dan melatih model SVM dan KNN Anda sendiri.\n\nMengevaluasi performa model Anda pada data pengujian.\n\nLatihan ini memberikan pemahaman yang lebih baik tentang bagaimana sistem klasifikasi gambar bekerja dengan menggunakan metode ekstraksi fitur dan model klasifikasi.\nEvaluasi Sistem\nEvaluasi sistem melibatkan perbandingan antara kelas sebenarnya dan kelas yang diprediksi oleh model.\n\nEvaluasi In-Sample: Selama proses pelatihan, akurasi pada data pelatihan akan dihitung.\n\nEvaluasi Out-of-Sample: Setelah model dilatih, akurasi pada data pengujian akan dihitung.\n\nDataset\nDataset yang digunakan terdiri dari 3 label yaitu label Kirei, Putri, dan Yudha dengan total sejumlah 353 citra berukuran 3024x3024 pixel.\nTiap label memiliki jumlah yang berbeda-beda, label Kirei sejumlah 107 citra, label Putri sejumlah 115 citra, dan label Yudha sejumlah 131 citra. Dataset yang terkumpul memiliki nilai eksposure yang bervariasi yaitu -2, -1, 0, 1, 2, sehingga setiap citra di dataset memiliki variasi nilai pixel yang cukup besar."
  }
]