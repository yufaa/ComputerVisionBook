<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Computer Vision - Modul 3. Dasar-dasar Image Processing</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./4_Feature_Extraction_and_Matching.html" rel="next">
<link href="./2_Python.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./3_Dasar_dasar_Image_Processing.html">Modul 3. Dasar-dasar Image Processing</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Computer Vision</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Computer Vision</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./1_Pengenalan_Computer_Vision_dan_Python.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Modul 1. Pengenalan Computer Vision dan Python</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2_Python.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Modul 2. Python</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3_Dasar_dasar_Image_Processing.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Modul 3. Dasar-dasar Image Processing</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./4_Feature_Extraction_and_Matching.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Modul 4. Feature Extraction and Matching</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#a.-pengenalan-image-processing" id="toc-a.-pengenalan-image-processing" class="nav-link active" data-scroll-target="#a.-pengenalan-image-processing">A. Pengenalan Image Processing</a></li>
  <li><a href="#b.-konsep-dasar-image-processing" id="toc-b.-konsep-dasar-image-processing" class="nav-link" data-scroll-target="#b.-konsep-dasar-image-processing">B. Konsep Dasar Image Processing</a></li>
  <li><a href="#c.-python-untuk-image-processing" id="toc-c.-python-untuk-image-processing" class="nav-link" data-scroll-target="#c.-python-untuk-image-processing">C. Python Untuk Image Processing</a>
  <ul class="collapse">
  <li><a href="#spatial-filter" id="toc-spatial-filter" class="nav-link" data-scroll-target="#spatial-filter">Spatial Filter</a></li>
  </ul></li>
  <li><a href="#rangkuman" id="toc-rangkuman" class="nav-link" data-scroll-target="#rangkuman">Rangkuman</a></li>
  <li><a href="#latihan-praktik" id="toc-latihan-praktik" class="nav-link" data-scroll-target="#latihan-praktik">Latihan Praktik</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Modul 3. Dasar-dasar Image Processing</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>Pada Modul ini membahas dasar-dasar image processing membahas konsep dasar dalam Image Processing, yang merupakan bagian penting dari Computer Vision. Anda akan mempelajari definisi Image Processing, aplikasinya dalam kehidupan sehari-hari, dan perbedaannya dengan Computer Vision. Selain itu, Anda akan memahami konsep dasar citra digital, termasuk operasi transformasi, filtering, dan edge detection. Penggunaan Python untuk Image Processing juga akan diajarkan, termasuk instalasi dan penggunaan library seperti OpenCV, TensorFlow, dan Keras. Modul ini juga mencakup latihan praktik untuk mengaplikasikan konsep dan teknik yang telah dipelajari. Dengan menyelesaikan Modul 2, Anda akan memiliki pemahaman yang kuat tentang dasar-dasar Image Processing dan keterampilan untuk mengimplementasikannya menggunakan Python.</p>
<section id="a.-pengenalan-image-processing" class="level2">
<h2 class="anchored" data-anchor-id="a.-pengenalan-image-processing">A. Pengenalan Image Processing</h2>
<p>Manusia mengandalkan penglihatan mereka untuk tugas-tugas mulai dari pengenalan pola hingga naluri bertahan hidup. Kemampuan manusia untuk melakukan analisis yang kompleks dan rinci terhadap suatu karya seni berdasarkan input visual adalah sesuatu yang luar biasa. Namun, sejauh mana manusia dapat melakukan apa yang komputer lakukan dengan sangat cepat masih perlu diteliti.<br>
Kebutuhan untuk mengekstrak informasi dari citra dan menginterpretasikan isinya telah menjadi salah satu faktor pendorong dalam perkembangan pemrosesan citra dan visi komputer selama beberapa dekade terakhir. Aplikasi pemrosesan citra meliputi berbagai aktivitas manusia, antara lain:</p>
<ul>
<li><p>Aplikasi medis: Modalitas pencitraan diagnostik seperti radiografi digital, PET (tomografi emisi positron), CT (tomografi aksial komputer), MRI (pemindaian resonansi magnetik), dan fMRI (pemindaian resonansi magnetik fungsional) telah diadopsi secara luas oleh komunitas medis.<br>
</p></li>
<li><p>Aplikasi industri: Sistem pemrosesan citra telah berhasil digunakan dalam sistem manufaktur untuk berbagai tugas, seperti sistem keamanan, kontrol kualitas, dan pengendalian kendaraan berpemandu otomatis (AGVs).<br>
</p></li>
<li><p>Aplikasi militer: Skenario yang paling menantang dan kritis dalam hal kinerja pemrosesan citra adalah untuk mendukung tugas militer, mulai dari deteksi tentara atau kendaraan hingga panduan rudal dan pengenalan objek dan tugas pengintaian menggunakan kendaraan udara tak berawak atau UAV. Selain itu, aplikasi militer sering kali membutuhkan penggunaan sensor pendeteksi yang khusus, seperti kamera jarak dan kamera inframerah yang melihat ke depan.</p></li>
<li><p>Penegakan hukum dan keamanan: Pengawasan adalah salah satu bidang yang banyak diteliti dalam komunitas pemrosesan video.<br>
</p></li>
<li><p>Teknologi biometrik (seperti pengenalan sidik jari, wajah, iris, dan telapak tangan) telah menjadi subjek penelitian dalam pemrosesan citra selama lebih dari satu dekade dan kini telah digunakan secara komersial.<br>
</p></li>
<li><p>Elektronik konsumen: Kamera digital dan camcorder, dengan kemampuan pemrosesan yang canggih, telah membuat film dan teknologi pita analog menjadi usang. Paket perangkat lunak untuk meningkatkan, mengedit, mengatur, dan mempublikasikan citra dan video telah maju pesat dalam kompleksitasnya sambil tetap menjaga antarmuka yang ramah pengguna. TV berdefinisi tinggi, monitor, pemutar DVD, dan pemutar video pribadi (PVR) semakin meningkat popularitasnya karena harga yang terjangkau. Perkembangan jaringan dan distribusi juga telah berhasil membuat terobosan dalam perangkat lain, seperti personal digital assistants (PDA), ponsel, dan pemutar musik portabel (MP3).<br>
</p></li>
<li><p>Internet, khususnya World Wide Web: Ada banyak informasi visual yang tersedia di web. Kolaborasi dalam mengunggah, berbagi, dan memberi anotasi (tagging) pada video semakin populer. Menemukan dan mengambil citra dan video di web berdasarkan isinya tetap menjadi tantangan terbuka dalam penelitian.</p></li>
</ul>
</section>
<section id="b.-konsep-dasar-image-processing" class="level2">
<h2 class="anchored" data-anchor-id="b.-konsep-dasar-image-processing">B. Konsep Dasar Image Processing</h2>
<p>Sebuah gambar digital merupakan larik 2D dari angka-angka yang mewakili versi sampel dari sebuah gambar. Gambar didefinisikan dalam bentuk grid, setiap lokasi grid disebut piksel. Sebuah gambar direpresentasikan oleh grid yang terbatas dan setiap nilai intensitas direpresentasikan oleh sejumlah bit yang terbatas. M x N pada gambar f(x, y) didefinisikan sebagai:</p>
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="Asset/image119.jpg" class="img-fluid"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="Asset/image120.jpg" class="img-fluid"></p>
</div>
</div>
</div>
<p>Dalam representasi ini, digunakan [0, L — 1] jumlah tingkat intensitas untuk mewakili semua nilai piksel grayscale, dan k jumlah bit digunakan untuk mewakili setiap tingkat intensitas, yaitu, L = 2k. Jadi, jumlah bit yang diperlukan untuk menyimpan gambar M x N adalah M x N x k. Kecerahan sebuah gambar merujuk pada tingkat keseluruhan cahaya atau kegelapan gambar, sementara kontras adalah perbedaan antara intensitas piksel maksimum dan minimum dalam sebuah gambar. Kecerahan dapat meningkat atau dikurangi dengan penambahan atau pengurangan sederhana pada nilai piksel.<br>
Sebuah gambar biner direpresentasikan oleh hanya satu bit. Di sisi lain, gambar grayscale direpresentasikan oleh 8 bit. Sebuah gambar raster adalah kumpulan titik-titik, yang disebut piksel. Sebuah gambar vektor adalah kumpulan garis dan kurva yang terhubung, dan digunakan untuk menghasilkan objek.<br>
Sebuah gambar adalah fungsi f, dari ruang R2 ke ruang R. Sebuah gambar direpresentasikan oleh f(x.y’), dan itu menunjukkan intensitas di posisi (x,y). Oleh karena itu, sebuah gambar hanya didefinisikan pada sebuah persegi panjang, dengan rentang yang terbatas, yaitu,<br>
<img src="Asset/image1111.png" class="img-fluid"><br>
Gambar berwarna memiliki komponen Merah (R), Hijau (G), dan Biru (B). Masing-masing dari ketiga komponen R, G, B biasanya direpresentasikan oleh 8 bit, dan oleh karena itu dibutuhkan 24-bit untuk sebuah gambar berwarna. Tiga warna primer ini dicampur dalam proporsi yang berbeda untuk mendapatkan warna-warna yang berbeda. Untuk berbagai aplikasi pengolahan gambar, format RGB, HIS, YIQ, YCbCr, dll. digunakan. Sebuah gambar berwarna adalah fungsi tiga komponen, yang merupakan fungsi “nilai-vektor”, dan direpresentasikan sebagai berikut:<br>
<img src="Asset/image1112.png" class="img-fluid"></p>
<p>Gambar terindeks memiliki peta warna yang terkait, yang merupakan daftar dari semua warna yang digunakan dalam gambar tersebut. Contoh dari format ini adalah gambar PNG dan GIF. Jadi, berbagai jenis gambar digital dapat dijelaskan sebagai berikut.</p>
<ul>
<li>Gambar biner - 1 bit/pixel</li>
<li>Gambar grayscale - 8 bit/pixel</li>
<li>Gambar warna asli atau RGB - 24 bit/pixel</li>
<li>Gambar terindeks - 8 bit/pixel</li>
</ul>
<p>Resolusi spasial sebuah gambar mendefinisikan jumlah piksel yang digunakan untuk mencakup ruang visual yang ditangkap oleh gambar tersebut. Resolusi intensitas sebuah gambar bergantung pada jumlah bit yang digunakan untuk mewakili nilai intensitas yang berbeda. Jumlah gambar atau frame video yang ditangkap oleh kamera dalam waktu tertentu menentukan resolusi temporal. Kurangnya jumlah tingkat intensitas (resolusi intensitas rendah) di area halus sebuah gambar menghasilkan “efek kontur palsu”, yaitu, menciptakan tepi atau garis palsu di mana aslinya tidak ada. Juga “efek kotak-kotak” terjadi ketika resolusi spasial sebuah gambar sangat rendah.<br>
Pengolahan gambar digital berurusan dengan manipulasi dan analisis gambar digital oleh sistem digital. Sebuah operasi pengolahan gambar biasanya mendefinisikan gambar baru g dalam hal gambar masukan f.&nbsp;Seperti yang ditunjukkan dalam Gambar 2.1, kita dapat mengubah rentang f menjadi g(x, y) = t(f(x,y)), atau kita dapat mengubah domain f menjadi g(x,y) = f(tx(x,y),ty(x,y)). Nilai piksel dimodifikasi dalam transformasi pertama (Gambar 2.1(a)); sedangkan posisi piksel spasial berubah dalam transformasi kedua (Gambar 2.1(b)). Domain sebuah gambar dapat diubah dengan memutar dan menyesuaikan skala gambar seperti yang diilustrasikan dalam Gambar 2.2.</p>
<div style="text-align:center">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Asset/image1113.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Mengubah Rentang Gambar</figcaption>
</figure>
</div>
</div>
<div style="text-align:center">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Asset/image1114.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Mengubah Domain dari Suatu Gambar</figcaption>
</figure>
</div>
</div>
</section>
<section id="c.-python-untuk-image-processing" class="level2">
<h2 class="anchored" data-anchor-id="c.-python-untuk-image-processing">C. Python Untuk Image Processing</h2>
<p>Dalam tutorial ini, Anda akan menemukan fungsi dasar untuk memuat, memanipulasi, dan menampilkan gambar. Informasi utama dari gambar akan diperoleh, seperti ukuran, jumlah saluran, kelas penyimpanan, dan lain-lain. Setelah itu, Anda akan dapat melakukan filter klasik pertama Anda.<br>
Proses yang berbeda akan dilakukan pada gambar-gambar berikut ini:<br>
<img src="Asset/image1115.png" class="img-fluid"></p>
<section id="spatial-filter" class="level3">
<h3 class="anchored" data-anchor-id="spatial-filter">Spatial Filter</h3>
<section id="filtering" class="level4">
<h4 class="anchored" data-anchor-id="filtering">Filtering</h4>
<p>Seperti halnya filter air yang menghilangkan kotoran, filter pemrosesan gambar menghapus fitur yang tidak diinginkan (seperti noise) dari sebuah gambar. Setiap filter memiliki utilitas khusus dan dirancang untuk menghilangkan jenis noise tertentu atau meningkatkan aspek tertentu dari gambar. Kami akan membahas banyak filter beserta tujuan dan efek mereka pada gambar.<br>
Untuk melakukan filtering, digunakan filter atau masker. Biasanya, ini berupa jendela persegi dua dimensi yang bergerak melintasi gambar hanya mempengaruhi satu piksel pada satu waktu. Setiap angka dalam filter dikenal sebagai koefisien. Koefisien dalam filter menentukan efek dari filter dan akibatnya gambar keluaran. Mari kita pertimbangkan filter 3x3, F, yang diberikan dalam Tabel 4.1.</p>
<p><img src="Asset/image1116.png" class="img-fluid" style="width:30.0%"></p>
<p>Jika (i, j) adalah piksel dalam gambar, maka sub-gambar di sekitar (i, j) dengan dimensi yang sama dengan filter akan dipertimbangkan untuk filtering. Pusat filter ditempatkan agar tumpang tindih dengan (i, j). Piksel-piksel dalam sub-gambar dikalikan dengan koefisien yang sesuai dalam filter. Hal ini menghasilkan matriks dengan ukuran yang sama dengan filter. Matriks ini disederhanakan menggunakan persamaan matematika untuk mendapatkan satu nilai yang akan menggantikan nilai piksel pada (i, j) dalam gambar. Persamaan matematika yang tepat tergantung pada jenis filter. Misalnya, dalam kasus filter rata-rata, nilai F adalah -7, di mana N adalah jumlah elemen dalam filter. Gambar yang difilter diperoleh dengan mengulangi proses penempatan filter pada setiap piksel dalam gambar, memperoleh satu nilai, dan menggantikan nilai piksel dalam gambar asli. Proses ini memindahkan jendela filter melintasi gambar disebut konvolusi dalam domain spasial.</p>
<p>Mari kita pertimbangkan sub-gambar berikut dari gambar I, yang berpusat pada (i, j).</p>
<div style="text-align:center">
<p><img src="Asset/image1117.png" class="img-fluid" style="width:70.0%"></p>
</div>
<p>Konvolusi filter yang diberikan dalam Tabel 4.1 dengan sub-gambar dalam Tabel 4.2 diberikan sebagai berikut:</p>
<div style="text-align:center">
<p><img src="Asset/image1118.png" class="img-fluid"></p>
</div>
<p>Di mana Inew(i, j) adalah nilai keluaran pada lokasi (i, j). Proses ini harus diulang untuk setiap piksel dalam gambar. Karena filter memainkan peran penting dalam proses konvolusi, filter juga dikenal sebagai kernel konvolusi.</p>
<p>Operasi konvolusi harus dilakukan pada setiap piksel dalam gambar, termasuk piksel di batas gambar. Ketika filter ditempatkan pada piksel batas, sebagian filter akan berada di luar batas gambar. Karena nilai piksel di luar batas tidak ada, nilai-nilai baru harus dibuat sebelum konvolusi. Proses ini untuk menciptakan nilai piksel di luar batas disebut padding. Piksel yang dipadatkan dapat diasumsikan nol atau nilai tetap. Pilihan padding lainnya seperti nearest neighbor atau reflect menciptakan piksel yang dipadatkan menggunakan nilai piksel dalam gambar. Dalam kasus nol, piksel yang dipadatkan semua bernilai nol. Dalam kasus konstan, piksel yang dipadatkan mengambil nilai spesifik. Dalam kasus reflect, piksel yang dipadatkan mengambil nilai dari baris atau kolom terakhir. Piksel yang dipadatkan hanya dipertimbangkan untuk konvolusi dan akan dibuang setelah konvolusi.</p>
<p>Mari kita pertimbangkan contoh untuk menunjukkan berbagai pilihan padding. Gambar 4.1(a) adalah gambar input berukuran 7x7 yang akan dikonvolusi menggunakan filter 3x5 dengan pusat filter di (1,2). Untuk memasukkan piksel batas dalam konvolusi, kita memasukkan gambar dengan satu baris di atas dan satu baris di bawah serta dua kolom di sebelah kiri dan dua kolom di sebelah kanan. Secara umum, ukuran filter menentukan jumlah baris dan kolom yang akan dipadatkan ke gambar.</p>
<ul>
<li>Padding dengan nol: Semua piksel yang dipadatkan diberi nilai nol (Gambar 4.1(b)).</li>
<li>Padding dengan konstanta: Nilai konstan 5 digunakan untuk semua piksel yang dipadatkan (Gambar 4.1(c)). Nilai konstan dapat dipilih berdasarkan jenis gambar yang sedang diproses.</li>
<li>Nearest neighbor: Nilai dari baris atau kolom terakhir (Gambar 4.1(d)) digunakan untuk padding.</li>
<li>Reflect: Nilai dari baris atau kolom terakhir (Gambar 4.1(e)) dipantulkan melintasi batas gambar.</li>
<li>Wrap: Dalam opsi wrap seperti yang ditunjukkan dalam Gambar 4.1(f), baris pertama (atau kolom) setelah batas mengambil nilai yang sama dengan baris pertama (atau kolom) dalam gambar, dan seterusnya.</li>
</ul>
<div style="text-align:center">
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Asset/image1119.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">7 x 7 input citra</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Asset/image1120.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Padding dengan kosong</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Asset/image1121.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Padding dengan nilai konstant</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Asset/image1122.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Padding dengan nearest neighbors</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Asset/image1123.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Padding dengan nearest neighbors</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Asset/image1124.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Padding dengan wrap option</figcaption>
</figure>
</div>
</div>
</div>
</div>
</div>
<section id="shape-detection-filter" class="level5">
<h5 class="anchored" data-anchor-id="shape-detection-filter"><strong>Shape Detection Filter</strong></h5>
<p><strong>Frangi Filter</strong></p>
<p>Kegunaan dari Filter Frangi [AFFV98] yaitu mendeteksi objek yang mirip dengan pembuluh darah pada sebuah gambar. Sebelum membahas matematika dibaliknya, pembahasan akan dimulai dengan ide fundamental dari Frangi itu sendiri. Pada gambar x.x.x berisi dua objek, salah satu objek memanjang ke satu arah, akan tetapi tidak ke arah lainnya, sedangkan objek kedua berbentuk persegi. Secara proporsional, panah ortogonal digambar dimana panjangnya sepanjang suatu arah tertentu. Dengan mendapatkan nilai eigen dari kedua objek tersebut, maka kita dapat mengukur perbedaan geometri kualitatif ini. Objek yang memanjang, nilai eigennya akan lebih besar pada arah panah yang lebih panjang serta lebih kecil pada arah panah yang lebih pendek. Sedangkan objek persegi, nilai eigen pada arah panah yang lebih panjang serupa dengan nilai eigen pada arah panah yang lebih pendek. Filter Frangi menggunakan gambar turunan kedua (Hessian) sebagai dasar perhitungan nilai eigen, bukan menggunakan gambar asli. Turunan kedua atau Hessian merupakan representasi matematis dari perubahan intensitas piksel dalam gambar. Dengan menggunakan gambar turunan kedua, Filter Frangi dapat mengidentifikasi dan menghitung nilai eigen yang mencerminkan karakteristik objek mirip pembuluh darah dengan lebih baik daripada menggunakan gambar asli. Maka dari itu, penggunaan gambar turunan kedua memungkinkan Filter Frangi untuk memperoleh informasi yang lebih relevan dan memperbaiki kemampuan deteksi objek pembuluh darah.</p>
<div style="text-align:center">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Asset/image1125.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Ilustrasi Frangi Filter</figcaption>
</figure>
</div>
</div>
<p>Noise yang disebabkan oleh turunan dapat dikurangi menggunakan konvolusi dimana gambar akan dihaluskan. Pada konteks umum, metode yang digunakan adalah penghalusan Gaussian. Penghalusan Gaussian merupakan teknik pengolahan citra yang menggunakan filter Gaussian untuk mengurangi nois dan menyamarkan detail tajam pada gambar. Dalam buku ini akan ditunjukkan bahwa mencari turunan dari gambar yang dihaluskan dengan konvolusi Gaussian setara dengan mencari turunan dari Gaussian yang dikonvolusikan dengan gambar. Selanjutnya, kami akan menghitung turunan kedua dari Gaussian dengan menggunakan rumus berikut ini, di mana gσ merupakan fungsi Gaussian.</p>
<p><img src="Asset/image1126.png" class="img-fluid"></p>
<p>Selanjutnya, menentukan turunan kedua lokal (Hessian) dan nilai eigen-nya. Untuk gambar 2D, setiap koordinat piksel akan memiliki dua nilai eigen (λ1 dan λ2). Kemudian, nilai eigen diurutkan dalam urutan meningkat. Sebuah piksel dianggap sebagai bagian dari struktur tabung atau mirip pembuluh darah jika λ1 ≈ 0 dan |λ2| &gt; |λ1|. Sedangkan untuk citra 3D, setiap koordinat voxel akan memiliki tiga nilai eigen (λ1, λ2, dan λ3). Nilai eigen tersebut kemudian diurutkan dalam urutan meningkat. Sebuah voxel dianggap sebagai bagian dari struktur tabung atau mirip pembuluh darah jika λ1 ≈ 0 sementara λ2 dan λ3 memiliki nilai absolut yang tinggi yang hampir sama dan memiliki tanda yang sama. Pembuluh yang terlihat terang akan memiliki nilai positif untuk λ2 dan λ3, sedangkan pembuluh yang lebih gelap akan memiliki nilai negatif untuk λ2 dan λ3.</p>
</section>
</section>
</section>
</section>
<section id="rangkuman" class="level2">
<h2 class="anchored" data-anchor-id="rangkuman">Rangkuman</h2>
<ul>
<li>Filter rata-rata menghaluskan gambar sambil mengaburkan bagian tepi dalam gambar.</li>
<li>Filter median efektif dalam menghilangkan noise salt-and-pepper.</li>
<li>Filter turunan pertama yang paling banyak digunakan adalah Sobel, Prewitt, dan Canny.</li>
<li>Baik Laplacian maupun LoG adalah filter turunan kedua yang populer. Laplacian sangat sensitif terhadap noise. Pada LoG, Gaussian menghaluskan gambar sehingga noise dari Laplacian dapat dikompensasi. Namun, LoG mengalami efek ‘spaghetti’. (*Efek ‘spaghetti’ merujuk pada hasil filter LoG yang menghasilkan garis-garis tipis seperti spageti yang melintang di sekitar tepi objek dalam gambar. Efek ini terjadi karena penggunaan kernel LoG yang besar atau parameter yang tidak sesuai, yang mengakibatkan respons yang berlebihan dan menciptakan garis-garis halus yang terlalu banyak pada tepi objek dalam gambar. Hasilnya adalah gambar yang terdistorsi dan sulit diinterpretasikan dengan jelas)</li>
<li>Filter Frangi digunakan untuk mendeteksi struktur yang mirip dengan pembuluh darah.</li>
</ul>
</section>
<section id="latihan-praktik" class="level2">
<h2 class="anchored" data-anchor-id="latihan-praktik">Latihan Praktik</h2>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./2_Python.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Modul 2. Python</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./4_Feature_Extraction_and_Matching.html" class="pagination-link">
        <span class="nav-page-text">Modul 4. Feature Extraction and Matching</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>